// Code generated by ecsgen; DO NOT EDIT.
package ecs

import (
	"encoding/json"
	"reflect"
	"time"
)

// Base defines the top level Elastic Common Schema (ECS) type. This type should be the default for interacting with ECS data, including the marshaling and unmarshaling of it.
type Base struct {
	AtTimestamp   time.Time              `json:"@timestamp,omitempty" yaml:"@timestamp,omitempty" ecs:"@timestamp"`
	Labels        map[string]interface{} `json:"labels,omitempty" yaml:"labels,omitempty" ecs:"labels"`
	Message       string                 `json:"message,omitempty" yaml:"message,omitempty" ecs:"message"`
	Tags          []string               `json:"tags,omitempty" yaml:"tags,omitempty" ecs:"tags"`
	Agent         Agent                  `json:"agent,omitempty" yaml:"agent,omitempty" ecs:"agent"`
	Client        Client                 `json:"client,omitempty" yaml:"client,omitempty" ecs:"client"`
	Cloud         Cloud                  `json:"cloud,omitempty" yaml:"cloud,omitempty" ecs:"cloud"`
	Container     Container              `json:"container,omitempty" yaml:"container,omitempty" ecs:"container"`
	Destination   Destination            `json:"destination,omitempty" yaml:"destination,omitempty" ecs:"destination"`
	DLL           DLL                    `json:"dll,omitempty" yaml:"dll,omitempty" ecs:"dll"`
	DNS           DNS                    `json:"dns,omitempty" yaml:"dns,omitempty" ecs:"dns"`
	ECS           ECS                    `json:"ecs,omitempty" yaml:"ecs,omitempty" ecs:"ecs"`
	Error         Error                  `json:"error,omitempty" yaml:"error,omitempty" ecs:"error"`
	Event         Event                  `json:"event,omitempty" yaml:"event,omitempty" ecs:"event"`
	File          File                   `json:"file,omitempty" yaml:"file,omitempty" ecs:"file"`
	Group         Group                  `json:"group,omitempty" yaml:"group,omitempty" ecs:"group"`
	Host          Host                   `json:"host,omitempty" yaml:"host,omitempty" ecs:"host"`
	HTTP          HTTP                   `json:"http,omitempty" yaml:"http,omitempty" ecs:"http"`
	Log           Log                    `json:"log,omitempty" yaml:"log,omitempty" ecs:"log"`
	Network       Network                `json:"network,omitempty" yaml:"network,omitempty" ecs:"network"`
	Observer      Observer               `json:"observer,omitempty" yaml:"observer,omitempty" ecs:"observer"`
	Organization  Organization           `json:"organization,omitempty" yaml:"organization,omitempty" ecs:"organization"`
	Package       Package                `json:"package,omitempty" yaml:"package,omitempty" ecs:"package"`
	Process       Process                `json:"process,omitempty" yaml:"process,omitempty" ecs:"process"`
	Registry      Registry               `json:"registry,omitempty" yaml:"registry,omitempty" ecs:"registry"`
	Related       Related                `json:"related,omitempty" yaml:"related,omitempty" ecs:"related"`
	Rule          Rule                   `json:"rule,omitempty" yaml:"rule,omitempty" ecs:"rule"`
	Server        Server                 `json:"server,omitempty" yaml:"server,omitempty" ecs:"server"`
	Service       Service                `json:"service,omitempty" yaml:"service,omitempty" ecs:"service"`
	Source        Source                 `json:"source,omitempty" yaml:"source,omitempty" ecs:"source"`
	Span          Span                   `json:"span,omitempty" yaml:"span,omitempty" ecs:"span"`
	Threat        Threat                 `json:"threat,omitempty" yaml:"threat,omitempty" ecs:"threat"`
	TLS           TLS                    `json:"tls,omitempty" yaml:"tls,omitempty" ecs:"tls"`
	Trace         Trace                  `json:"trace,omitempty" yaml:"trace,omitempty" ecs:"trace"`
	Transaction   Transaction            `json:"transaction,omitempty" yaml:"transaction,omitempty" ecs:"transaction"`
	URL           URL                    `json:"url,omitempty" yaml:"url,omitempty" ecs:"url"`
	User          User                   `json:"user,omitempty" yaml:"user,omitempty" ecs:"user"`
	UserAgent     UserAgent              `json:"user_agent,omitempty" yaml:"user_agent,omitempty" ecs:"user_agent"`
	Vulnerability Vulnerability          `json:"vulnerability,omitempty" yaml:"vulnerability,omitempty" ecs:"vulnerability"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b Base) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.AtTimestamp); !val.IsZero() {
		res["@timestamp"] = b.AtTimestamp
	}

	if val := reflect.ValueOf(b.Labels); !val.IsZero() {
		res["labels"] = b.Labels
	}

	if val := reflect.ValueOf(b.Message); !val.IsZero() {
		res["message"] = b.Message
	}

	if val := reflect.ValueOf(b.Tags); !val.IsZero() {
		res["tags"] = b.Tags
	}

	if val := reflect.ValueOf(b.Agent); !val.IsZero() {
		res["agent"] = b.Agent
	}

	if val := reflect.ValueOf(b.Client); !val.IsZero() {
		res["client"] = b.Client
	}

	if val := reflect.ValueOf(b.Cloud); !val.IsZero() {
		res["cloud"] = b.Cloud
	}

	if val := reflect.ValueOf(b.Container); !val.IsZero() {
		res["container"] = b.Container
	}

	if val := reflect.ValueOf(b.Destination); !val.IsZero() {
		res["destination"] = b.Destination
	}

	if val := reflect.ValueOf(b.DLL); !val.IsZero() {
		res["dll"] = b.DLL
	}

	if val := reflect.ValueOf(b.DNS); !val.IsZero() {
		res["dns"] = b.DNS
	}

	if val := reflect.ValueOf(b.ECS); !val.IsZero() {
		res["ecs"] = b.ECS
	}

	if val := reflect.ValueOf(b.Error); !val.IsZero() {
		res["error"] = b.Error
	}

	if val := reflect.ValueOf(b.Event); !val.IsZero() {
		res["event"] = b.Event
	}

	if val := reflect.ValueOf(b.File); !val.IsZero() {
		res["file"] = b.File
	}

	if val := reflect.ValueOf(b.Group); !val.IsZero() {
		res["group"] = b.Group
	}

	if val := reflect.ValueOf(b.Host); !val.IsZero() {
		res["host"] = b.Host
	}

	if val := reflect.ValueOf(b.HTTP); !val.IsZero() {
		res["http"] = b.HTTP
	}

	if val := reflect.ValueOf(b.Log); !val.IsZero() {
		res["log"] = b.Log
	}

	if val := reflect.ValueOf(b.Network); !val.IsZero() {
		res["network"] = b.Network
	}

	if val := reflect.ValueOf(b.Observer); !val.IsZero() {
		res["observer"] = b.Observer
	}

	if val := reflect.ValueOf(b.Organization); !val.IsZero() {
		res["organization"] = b.Organization
	}

	if val := reflect.ValueOf(b.Package); !val.IsZero() {
		res["package"] = b.Package
	}

	if val := reflect.ValueOf(b.Process); !val.IsZero() {
		res["process"] = b.Process
	}

	if val := reflect.ValueOf(b.Registry); !val.IsZero() {
		res["registry"] = b.Registry
	}

	if val := reflect.ValueOf(b.Related); !val.IsZero() {
		res["related"] = b.Related
	}

	if val := reflect.ValueOf(b.Rule); !val.IsZero() {
		res["rule"] = b.Rule
	}

	if val := reflect.ValueOf(b.Server); !val.IsZero() {
		res["server"] = b.Server
	}

	if val := reflect.ValueOf(b.Service); !val.IsZero() {
		res["service"] = b.Service
	}

	if val := reflect.ValueOf(b.Source); !val.IsZero() {
		res["source"] = b.Source
	}

	if val := reflect.ValueOf(b.Span); !val.IsZero() {
		res["span"] = b.Span
	}

	if val := reflect.ValueOf(b.Threat); !val.IsZero() {
		res["threat"] = b.Threat
	}

	if val := reflect.ValueOf(b.TLS); !val.IsZero() {
		res["tls"] = b.TLS
	}

	if val := reflect.ValueOf(b.Trace); !val.IsZero() {
		res["trace"] = b.Trace
	}

	if val := reflect.ValueOf(b.Transaction); !val.IsZero() {
		res["transaction"] = b.Transaction
	}

	if val := reflect.ValueOf(b.URL); !val.IsZero() {
		res["url"] = b.URL
	}

	if val := reflect.ValueOf(b.User); !val.IsZero() {
		res["user"] = b.User
	}

	if val := reflect.ValueOf(b.UserAgent); !val.IsZero() {
		res["user_agent"] = b.UserAgent
	}

	if val := reflect.ValueOf(b.Vulnerability); !val.IsZero() {
		res["vulnerability"] = b.Vulnerability
	}

	return JSONMarshalNoHTMLEscape(res)
}

// Agent defines the object located at ECS path agent.
type Agent struct {
	Build       AgentBuild `json:"build,omitempty" yaml:"build,omitempty" ecs:"agent.build"`
	EphemeralID string     `json:"ephemeral_id,omitempty" yaml:"ephemeral_id,omitempty" ecs:"agent.ephemeral_id"`
	ID          string     `json:"id,omitempty" yaml:"id,omitempty" ecs:"agent.id"`
	Name        string     `json:"name,omitempty" yaml:"name,omitempty" ecs:"agent.name"`
	Type        string     `json:"type,omitempty" yaml:"type,omitempty" ecs:"agent.type"`
	Version     string     `json:"version,omitempty" yaml:"version,omitempty" ecs:"agent.version"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b Agent) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Build); !val.IsZero() {
		res["build"] = b.Build
	}

	if val := reflect.ValueOf(b.EphemeralID); !val.IsZero() {
		res["ephemeral_id"] = b.EphemeralID
	}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	if val := reflect.ValueOf(b.Type); !val.IsZero() {
		res["type"] = b.Type
	}

	if val := reflect.ValueOf(b.Version); !val.IsZero() {
		res["version"] = b.Version
	}

	return json.Marshal(res)
}

// AgentBuild defines the object located at ECS path agent.build.
type AgentBuild struct {
	Original string `json:"original,omitempty" yaml:"original,omitempty" ecs:"agent.build.original"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b AgentBuild) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Original); !val.IsZero() {
		res["original"] = b.Original
	}

	return json.Marshal(res)
}

// Client defines the object located at ECS path client.
type Client struct {
	Address          string      `json:"address,omitempty" yaml:"address,omitempty" ecs:"client.address"`
	AS               ClientAS    `json:"as,omitempty" yaml:"as,omitempty" ecs:"client.as"`
	Bytes            json.Number `json:"bytes,omitempty" yaml:"bytes,omitempty" ecs:"client.bytes"`
	Domain           string      `json:"domain,omitempty" yaml:"domain,omitempty" ecs:"client.domain"`
	Geo              ClientGeo   `json:"geo,omitempty" yaml:"geo,omitempty" ecs:"client.geo"`
	IP               string      `json:"ip,omitempty" yaml:"ip,omitempty" ecs:"client.ip"`
	MAC              string      `json:"mac,omitempty" yaml:"mac,omitempty" ecs:"client.mac"`
	NAT              ClientNAT   `json:"nat,omitempty" yaml:"nat,omitempty" ecs:"client.nat"`
	Packets          json.Number `json:"packets,omitempty" yaml:"packets,omitempty" ecs:"client.packets"`
	Port             json.Number `json:"port,omitempty" yaml:"port,omitempty" ecs:"client.port"`
	RegisteredDomain string      `json:"registered_domain,omitempty" yaml:"registered_domain,omitempty" ecs:"client.registered_domain"`
	TopLevelDomain   string      `json:"top_level_domain,omitempty" yaml:"top_level_domain,omitempty" ecs:"client.top_level_domain"`
	User             ClientUser  `json:"user,omitempty" yaml:"user,omitempty" ecs:"client.user"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b Client) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Address); !val.IsZero() {
		res["address"] = b.Address
	}

	if val := reflect.ValueOf(b.AS); !val.IsZero() {
		res["as"] = b.AS
	}

	if val := reflect.ValueOf(b.Bytes); !val.IsZero() {
		res["bytes"] = b.Bytes
	}

	if val := reflect.ValueOf(b.Domain); !val.IsZero() {
		res["domain"] = b.Domain
	}

	if val := reflect.ValueOf(b.Geo); !val.IsZero() {
		res["geo"] = b.Geo
	}

	if val := reflect.ValueOf(b.IP); !val.IsZero() {
		res["ip"] = b.IP
	}

	if val := reflect.ValueOf(b.MAC); !val.IsZero() {
		res["mac"] = b.MAC
	}

	if val := reflect.ValueOf(b.NAT); !val.IsZero() {
		res["nat"] = b.NAT
	}

	if val := reflect.ValueOf(b.Packets); !val.IsZero() {
		res["packets"] = b.Packets
	}

	if val := reflect.ValueOf(b.Port); !val.IsZero() {
		res["port"] = b.Port
	}

	if val := reflect.ValueOf(b.RegisteredDomain); !val.IsZero() {
		res["registered_domain"] = b.RegisteredDomain
	}

	if val := reflect.ValueOf(b.TopLevelDomain); !val.IsZero() {
		res["top_level_domain"] = b.TopLevelDomain
	}

	if val := reflect.ValueOf(b.User); !val.IsZero() {
		res["user"] = b.User
	}

	return json.Marshal(res)
}

// ClientAS defines the object located at ECS path client.as.
type ClientAS struct {
	Number       json.Number          `json:"number,omitempty" yaml:"number,omitempty" ecs:"client.as.number"`
	Organization ClientASOrganization `json:"organization,omitempty" yaml:"organization,omitempty" ecs:"client.as.organization"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b ClientAS) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Number); !val.IsZero() {
		res["number"] = b.Number
	}

	if val := reflect.ValueOf(b.Organization); !val.IsZero() {
		res["organization"] = b.Organization
	}

	return json.Marshal(res)
}

// ClientASOrganization defines the object located at ECS path client.as.organization.
type ClientASOrganization struct {
	Name string `json:"name,omitempty" yaml:"name,omitempty" ecs:"client.as.organization.name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b ClientASOrganization) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	return json.Marshal(res)
}

// ClientGeo defines the object located at ECS path client.geo.
type ClientGeo struct {
	CityName       string         `json:"city_name,omitempty" yaml:"city_name,omitempty" ecs:"client.geo.city_name"`
	ContinentName  string         `json:"continent_name,omitempty" yaml:"continent_name,omitempty" ecs:"client.geo.continent_name"`
	CountryISOCode string         `json:"country_iso_code,omitempty" yaml:"country_iso_code,omitempty" ecs:"client.geo.country_iso_code"`
	CountryName    string         `json:"country_name,omitempty" yaml:"country_name,omitempty" ecs:"client.geo.country_name"`
	Location       ClientGeoPoint `json:"location,omitempty" yaml:"location,omitempty" ecs:"client.geo.location"`
	Name           string         `json:"name,omitempty" yaml:"name,omitempty" ecs:"client.geo.name"`
	RegionISOCode  string         `json:"region_iso_code,omitempty" yaml:"region_iso_code,omitempty" ecs:"client.geo.region_iso_code"`
	RegionName     string         `json:"region_name,omitempty" yaml:"region_name,omitempty" ecs:"client.geo.region_name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b ClientGeo) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.CityName); !val.IsZero() {
		res["city_name"] = b.CityName
	}

	if val := reflect.ValueOf(b.ContinentName); !val.IsZero() {
		res["continent_name"] = b.ContinentName
	}

	if val := reflect.ValueOf(b.CountryISOCode); !val.IsZero() {
		res["country_iso_code"] = b.CountryISOCode
	}

	if val := reflect.ValueOf(b.CountryName); !val.IsZero() {
		res["country_name"] = b.CountryName
	}

	if val := reflect.ValueOf(b.Location); !val.IsZero() {
		res["location"] = b.Location
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	if val := reflect.ValueOf(b.RegionISOCode); !val.IsZero() {
		res["region_iso_code"] = b.RegionISOCode
	}

	if val := reflect.ValueOf(b.RegionName); !val.IsZero() {
		res["region_name"] = b.RegionName
	}

	return json.Marshal(res)
}

// GeoPoint defines the object at ECS path client.geo.location
type ClientGeoPoint struct {
	Latitude  json.Number `json:"lat,omitempty" yaml:"lat,omitempty" ecs:"client.geo.location.lat"`
	Longitude json.Number `json:"lon,omitempty" yaml:"lon,omitempty" ecs:"client.geo.location.lon"`
}

func (b ClientGeoPoint) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Latitude); !val.IsZero() {
		res["lat"] = b.Latitude
	}

	if val := reflect.ValueOf(b.Longitude); !val.IsZero() {
		res["lon"] = b.Longitude
	}

	return json.Marshal(res)
}

// ClientNAT defines the object located at ECS path client.nat.
type ClientNAT struct {
	IP   string      `json:"ip,omitempty" yaml:"ip,omitempty" ecs:"client.nat.ip"`
	Port json.Number `json:"port,omitempty" yaml:"port,omitempty" ecs:"client.nat.port"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b ClientNAT) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.IP); !val.IsZero() {
		res["ip"] = b.IP
	}

	if val := reflect.ValueOf(b.Port); !val.IsZero() {
		res["port"] = b.Port
	}

	return json.Marshal(res)
}

// ClientUser defines the object located at ECS path client.user.
type ClientUser struct {
	Domain   string          `json:"domain,omitempty" yaml:"domain,omitempty" ecs:"client.user.domain"`
	Email    string          `json:"email,omitempty" yaml:"email,omitempty" ecs:"client.user.email"`
	FullName string          `json:"full_name,omitempty" yaml:"full_name,omitempty" ecs:"client.user.full_name"`
	Group    ClientUserGroup `json:"group,omitempty" yaml:"group,omitempty" ecs:"client.user.group"`
	Hash     string          `json:"hash,omitempty" yaml:"hash,omitempty" ecs:"client.user.hash"`
	ID       string          `json:"id,omitempty" yaml:"id,omitempty" ecs:"client.user.id"`
	Name     string          `json:"name,omitempty" yaml:"name,omitempty" ecs:"client.user.name"`
	Roles    []string        `json:"roles,omitempty" yaml:"roles,omitempty" ecs:"client.user.roles"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b ClientUser) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Domain); !val.IsZero() {
		res["domain"] = b.Domain
	}

	if val := reflect.ValueOf(b.Email); !val.IsZero() {
		res["email"] = b.Email
	}

	if val := reflect.ValueOf(b.FullName); !val.IsZero() {
		res["full_name"] = b.FullName
	}

	if val := reflect.ValueOf(b.Group); !val.IsZero() {
		res["group"] = b.Group
	}

	if val := reflect.ValueOf(b.Hash); !val.IsZero() {
		res["hash"] = b.Hash
	}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	if val := reflect.ValueOf(b.Roles); !val.IsZero() {
		res["roles"] = b.Roles
	}

	return json.Marshal(res)
}

// ClientUserGroup defines the object located at ECS path client.user.group.
type ClientUserGroup struct {
	Domain string `json:"domain,omitempty" yaml:"domain,omitempty" ecs:"client.user.group.domain"`
	ID     string `json:"id,omitempty" yaml:"id,omitempty" ecs:"client.user.group.id"`
	Name   string `json:"name,omitempty" yaml:"name,omitempty" ecs:"client.user.group.name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b ClientUserGroup) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Domain); !val.IsZero() {
		res["domain"] = b.Domain
	}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	return json.Marshal(res)
}

// Cloud defines the object located at ECS path cloud.
type Cloud struct {
	Account          CloudAccount  `json:"account,omitempty" yaml:"account,omitempty" ecs:"cloud.account"`
	AvailabilityZone string        `json:"availability_zone,omitempty" yaml:"availability_zone,omitempty" ecs:"cloud.availability_zone"`
	Instance         CloudInstance `json:"instance,omitempty" yaml:"instance,omitempty" ecs:"cloud.instance"`
	Machine          CloudMachine  `json:"machine,omitempty" yaml:"machine,omitempty" ecs:"cloud.machine"`
	Project          CloudProject  `json:"project,omitempty" yaml:"project,omitempty" ecs:"cloud.project"`
	Provider         string        `json:"provider,omitempty" yaml:"provider,omitempty" ecs:"cloud.provider"`
	Region           string        `json:"region,omitempty" yaml:"region,omitempty" ecs:"cloud.region"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b Cloud) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Account); !val.IsZero() {
		res["account"] = b.Account
	}

	if val := reflect.ValueOf(b.AvailabilityZone); !val.IsZero() {
		res["availability_zone"] = b.AvailabilityZone
	}

	if val := reflect.ValueOf(b.Instance); !val.IsZero() {
		res["instance"] = b.Instance
	}

	if val := reflect.ValueOf(b.Machine); !val.IsZero() {
		res["machine"] = b.Machine
	}

	if val := reflect.ValueOf(b.Project); !val.IsZero() {
		res["project"] = b.Project
	}

	if val := reflect.ValueOf(b.Provider); !val.IsZero() {
		res["provider"] = b.Provider
	}

	if val := reflect.ValueOf(b.Region); !val.IsZero() {
		res["region"] = b.Region
	}

	return json.Marshal(res)
}

// CloudAccount defines the object located at ECS path cloud.account.
type CloudAccount struct {
	ID   string `json:"id,omitempty" yaml:"id,omitempty" ecs:"cloud.account.id"`
	Name string `json:"name,omitempty" yaml:"name,omitempty" ecs:"cloud.account.name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b CloudAccount) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	return json.Marshal(res)
}

// CloudInstance defines the object located at ECS path cloud.instance.
type CloudInstance struct {
	ID   string `json:"id,omitempty" yaml:"id,omitempty" ecs:"cloud.instance.id"`
	Name string `json:"name,omitempty" yaml:"name,omitempty" ecs:"cloud.instance.name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b CloudInstance) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	return json.Marshal(res)
}

// CloudMachine defines the object located at ECS path cloud.machine.
type CloudMachine struct {
	Type string `json:"type,omitempty" yaml:"type,omitempty" ecs:"cloud.machine.type"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b CloudMachine) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Type); !val.IsZero() {
		res["type"] = b.Type
	}

	return json.Marshal(res)
}

// CloudProject defines the object located at ECS path cloud.project.
type CloudProject struct {
	ID   string `json:"id,omitempty" yaml:"id,omitempty" ecs:"cloud.project.id"`
	Name string `json:"name,omitempty" yaml:"name,omitempty" ecs:"cloud.project.name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b CloudProject) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	return json.Marshal(res)
}

// Container defines the object located at ECS path container.
type Container struct {
	ID      string                 `json:"id,omitempty" yaml:"id,omitempty" ecs:"container.id"`
	Image   ContainerImage         `json:"image,omitempty" yaml:"image,omitempty" ecs:"container.image"`
	Labels  map[string]interface{} `json:"labels,omitempty" yaml:"labels,omitempty" ecs:"container.labels"`
	Name    string                 `json:"name,omitempty" yaml:"name,omitempty" ecs:"container.name"`
	Runtime string                 `json:"runtime,omitempty" yaml:"runtime,omitempty" ecs:"container.runtime"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b Container) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.Image); !val.IsZero() {
		res["image"] = b.Image
	}

	if val := reflect.ValueOf(b.Labels); !val.IsZero() {
		res["labels"] = b.Labels
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	if val := reflect.ValueOf(b.Runtime); !val.IsZero() {
		res["runtime"] = b.Runtime
	}

	return json.Marshal(res)
}

// ContainerImage defines the object located at ECS path container.image.
type ContainerImage struct {
	Name string   `json:"name,omitempty" yaml:"name,omitempty" ecs:"container.image.name"`
	Tag  []string `json:"tag,omitempty" yaml:"tag,omitempty" ecs:"container.image.tag"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b ContainerImage) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	if val := reflect.ValueOf(b.Tag); !val.IsZero() {
		res["tag"] = b.Tag
	}

	return json.Marshal(res)
}

// Destination defines the object located at ECS path destination.
type Destination struct {
	Address          string          `json:"address,omitempty" yaml:"address,omitempty" ecs:"destination.address"`
	AS               DestinationAS   `json:"as,omitempty" yaml:"as,omitempty" ecs:"destination.as"`
	Bytes            json.Number     `json:"bytes,omitempty" yaml:"bytes,omitempty" ecs:"destination.bytes"`
	Domain           string          `json:"domain,omitempty" yaml:"domain,omitempty" ecs:"destination.domain"`
	Geo              DestinationGeo  `json:"geo,omitempty" yaml:"geo,omitempty" ecs:"destination.geo"`
	IP               string          `json:"ip,omitempty" yaml:"ip,omitempty" ecs:"destination.ip"`
	MAC              string          `json:"mac,omitempty" yaml:"mac,omitempty" ecs:"destination.mac"`
	NAT              DestinationNAT  `json:"nat,omitempty" yaml:"nat,omitempty" ecs:"destination.nat"`
	Packets          json.Number     `json:"packets,omitempty" yaml:"packets,omitempty" ecs:"destination.packets"`
	Port             json.Number     `json:"port,omitempty" yaml:"port,omitempty" ecs:"destination.port"`
	RegisteredDomain string          `json:"registered_domain,omitempty" yaml:"registered_domain,omitempty" ecs:"destination.registered_domain"`
	TopLevelDomain   string          `json:"top_level_domain,omitempty" yaml:"top_level_domain,omitempty" ecs:"destination.top_level_domain"`
	User             DestinationUser `json:"user,omitempty" yaml:"user,omitempty" ecs:"destination.user"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b Destination) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Address); !val.IsZero() {
		res["address"] = b.Address
	}

	if val := reflect.ValueOf(b.AS); !val.IsZero() {
		res["as"] = b.AS
	}

	if val := reflect.ValueOf(b.Bytes); !val.IsZero() {
		res["bytes"] = b.Bytes
	}

	if val := reflect.ValueOf(b.Domain); !val.IsZero() {
		res["domain"] = b.Domain
	}

	if val := reflect.ValueOf(b.Geo); !val.IsZero() {
		res["geo"] = b.Geo
	}

	if val := reflect.ValueOf(b.IP); !val.IsZero() {
		res["ip"] = b.IP
	}

	if val := reflect.ValueOf(b.MAC); !val.IsZero() {
		res["mac"] = b.MAC
	}

	if val := reflect.ValueOf(b.NAT); !val.IsZero() {
		res["nat"] = b.NAT
	}

	if val := reflect.ValueOf(b.Packets); !val.IsZero() {
		res["packets"] = b.Packets
	}

	if val := reflect.ValueOf(b.Port); !val.IsZero() {
		res["port"] = b.Port
	}

	if val := reflect.ValueOf(b.RegisteredDomain); !val.IsZero() {
		res["registered_domain"] = b.RegisteredDomain
	}

	if val := reflect.ValueOf(b.TopLevelDomain); !val.IsZero() {
		res["top_level_domain"] = b.TopLevelDomain
	}

	if val := reflect.ValueOf(b.User); !val.IsZero() {
		res["user"] = b.User
	}

	return json.Marshal(res)
}

// DestinationAS defines the object located at ECS path destination.as.
type DestinationAS struct {
	Number       json.Number               `json:"number,omitempty" yaml:"number,omitempty" ecs:"destination.as.number"`
	Organization DestinationASOrganization `json:"organization,omitempty" yaml:"organization,omitempty" ecs:"destination.as.organization"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b DestinationAS) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Number); !val.IsZero() {
		res["number"] = b.Number
	}

	if val := reflect.ValueOf(b.Organization); !val.IsZero() {
		res["organization"] = b.Organization
	}

	return json.Marshal(res)
}

// DestinationASOrganization defines the object located at ECS path destination.as.organization.
type DestinationASOrganization struct {
	Name string `json:"name,omitempty" yaml:"name,omitempty" ecs:"destination.as.organization.name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b DestinationASOrganization) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	return json.Marshal(res)
}

// DestinationGeo defines the object located at ECS path destination.geo.
type DestinationGeo struct {
	CityName       string              `json:"city_name,omitempty" yaml:"city_name,omitempty" ecs:"destination.geo.city_name"`
	ContinentName  string              `json:"continent_name,omitempty" yaml:"continent_name,omitempty" ecs:"destination.geo.continent_name"`
	CountryISOCode string              `json:"country_iso_code,omitempty" yaml:"country_iso_code,omitempty" ecs:"destination.geo.country_iso_code"`
	CountryName    string              `json:"country_name,omitempty" yaml:"country_name,omitempty" ecs:"destination.geo.country_name"`
	Location       DestinationGeoPoint `json:"location,omitempty" yaml:"location,omitempty" ecs:"destination.geo.location"`
	Name           string              `json:"name,omitempty" yaml:"name,omitempty" ecs:"destination.geo.name"`
	RegionISOCode  string              `json:"region_iso_code,omitempty" yaml:"region_iso_code,omitempty" ecs:"destination.geo.region_iso_code"`
	RegionName     string              `json:"region_name,omitempty" yaml:"region_name,omitempty" ecs:"destination.geo.region_name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b DestinationGeo) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.CityName); !val.IsZero() {
		res["city_name"] = b.CityName
	}

	if val := reflect.ValueOf(b.ContinentName); !val.IsZero() {
		res["continent_name"] = b.ContinentName
	}

	if val := reflect.ValueOf(b.CountryISOCode); !val.IsZero() {
		res["country_iso_code"] = b.CountryISOCode
	}

	if val := reflect.ValueOf(b.CountryName); !val.IsZero() {
		res["country_name"] = b.CountryName
	}

	if val := reflect.ValueOf(b.Location); !val.IsZero() {
		res["location"] = b.Location
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	if val := reflect.ValueOf(b.RegionISOCode); !val.IsZero() {
		res["region_iso_code"] = b.RegionISOCode
	}

	if val := reflect.ValueOf(b.RegionName); !val.IsZero() {
		res["region_name"] = b.RegionName
	}

	return json.Marshal(res)
}

// GeoPoint defines the object at ECS path destination.geo.location
type DestinationGeoPoint struct {
	Latitude  json.Number `json:"lat,omitempty" yaml:"lat,omitempty" ecs:"destination.geo.location.lat"`
	Longitude json.Number `json:"lon,omitempty" yaml:"lon,omitempty" ecs:"destination.geo.location.lon"`
}

func (b DestinationGeoPoint) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Latitude); !val.IsZero() {
		res["lat"] = b.Latitude
	}

	if val := reflect.ValueOf(b.Longitude); !val.IsZero() {
		res["lon"] = b.Longitude
	}

	return json.Marshal(res)
}

// DestinationNAT defines the object located at ECS path destination.nat.
type DestinationNAT struct {
	IP   string      `json:"ip,omitempty" yaml:"ip,omitempty" ecs:"destination.nat.ip"`
	Port json.Number `json:"port,omitempty" yaml:"port,omitempty" ecs:"destination.nat.port"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b DestinationNAT) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.IP); !val.IsZero() {
		res["ip"] = b.IP
	}

	if val := reflect.ValueOf(b.Port); !val.IsZero() {
		res["port"] = b.Port
	}

	return json.Marshal(res)
}

// DestinationUser defines the object located at ECS path destination.user.
type DestinationUser struct {
	Domain   string               `json:"domain,omitempty" yaml:"domain,omitempty" ecs:"destination.user.domain"`
	Email    string               `json:"email,omitempty" yaml:"email,omitempty" ecs:"destination.user.email"`
	FullName string               `json:"full_name,omitempty" yaml:"full_name,omitempty" ecs:"destination.user.full_name"`
	Group    DestinationUserGroup `json:"group,omitempty" yaml:"group,omitempty" ecs:"destination.user.group"`
	Hash     string               `json:"hash,omitempty" yaml:"hash,omitempty" ecs:"destination.user.hash"`
	ID       string               `json:"id,omitempty" yaml:"id,omitempty" ecs:"destination.user.id"`
	Name     string               `json:"name,omitempty" yaml:"name,omitempty" ecs:"destination.user.name"`
	Roles    []string             `json:"roles,omitempty" yaml:"roles,omitempty" ecs:"destination.user.roles"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b DestinationUser) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Domain); !val.IsZero() {
		res["domain"] = b.Domain
	}

	if val := reflect.ValueOf(b.Email); !val.IsZero() {
		res["email"] = b.Email
	}

	if val := reflect.ValueOf(b.FullName); !val.IsZero() {
		res["full_name"] = b.FullName
	}

	if val := reflect.ValueOf(b.Group); !val.IsZero() {
		res["group"] = b.Group
	}

	if val := reflect.ValueOf(b.Hash); !val.IsZero() {
		res["hash"] = b.Hash
	}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	if val := reflect.ValueOf(b.Roles); !val.IsZero() {
		res["roles"] = b.Roles
	}

	return json.Marshal(res)
}

// DestinationUserGroup defines the object located at ECS path destination.user.group.
type DestinationUserGroup struct {
	Domain string `json:"domain,omitempty" yaml:"domain,omitempty" ecs:"destination.user.group.domain"`
	ID     string `json:"id,omitempty" yaml:"id,omitempty" ecs:"destination.user.group.id"`
	Name   string `json:"name,omitempty" yaml:"name,omitempty" ecs:"destination.user.group.name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b DestinationUserGroup) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Domain); !val.IsZero() {
		res["domain"] = b.Domain
	}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	return json.Marshal(res)
}

// DLL defines the object located at ECS path dll.
type DLL struct {
	CodeSignature DLLCodeSignature `json:"code_signature,omitempty" yaml:"code_signature,omitempty" ecs:"dll.code_signature"`
	Hash          DLLHash          `json:"hash,omitempty" yaml:"hash,omitempty" ecs:"dll.hash"`
	Name          string           `json:"name,omitempty" yaml:"name,omitempty" ecs:"dll.name"`
	Path          string           `json:"path,omitempty" yaml:"path,omitempty" ecs:"dll.path"`
	PE            DLLPE            `json:"pe,omitempty" yaml:"pe,omitempty" ecs:"dll.pe"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b DLL) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.CodeSignature); !val.IsZero() {
		res["code_signature"] = b.CodeSignature
	}

	if val := reflect.ValueOf(b.Hash); !val.IsZero() {
		res["hash"] = b.Hash
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	if val := reflect.ValueOf(b.Path); !val.IsZero() {
		res["path"] = b.Path
	}

	if val := reflect.ValueOf(b.PE); !val.IsZero() {
		res["pe"] = b.PE
	}

	return json.Marshal(res)
}

// DLLCodeSignature defines the object located at ECS path dll.code_signature.
type DLLCodeSignature struct {
	Exists      bool   `json:"exists,omitempty" yaml:"exists,omitempty" ecs:"dll.code_signature.exists"`
	Status      string `json:"status,omitempty" yaml:"status,omitempty" ecs:"dll.code_signature.status"`
	SubjectName string `json:"subject_name,omitempty" yaml:"subject_name,omitempty" ecs:"dll.code_signature.subject_name"`
	Trusted     bool   `json:"trusted,omitempty" yaml:"trusted,omitempty" ecs:"dll.code_signature.trusted"`
	Valid       bool   `json:"valid,omitempty" yaml:"valid,omitempty" ecs:"dll.code_signature.valid"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b DLLCodeSignature) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Exists); !val.IsZero() {
		res["exists"] = b.Exists
	}

	if val := reflect.ValueOf(b.Status); !val.IsZero() {
		res["status"] = b.Status
	}

	if val := reflect.ValueOf(b.SubjectName); !val.IsZero() {
		res["subject_name"] = b.SubjectName
	}

	if val := reflect.ValueOf(b.Trusted); !val.IsZero() {
		res["trusted"] = b.Trusted
	}

	if val := reflect.ValueOf(b.Valid); !val.IsZero() {
		res["valid"] = b.Valid
	}

	return json.Marshal(res)
}

// DLLHash defines the object located at ECS path dll.hash.
type DLLHash struct {
	MD5    string `json:"md5,omitempty" yaml:"md5,omitempty" ecs:"dll.hash.md5"`
	SHA1   string `json:"sha1,omitempty" yaml:"sha1,omitempty" ecs:"dll.hash.sha1"`
	SHA256 string `json:"sha256,omitempty" yaml:"sha256,omitempty" ecs:"dll.hash.sha256"`
	SHA512 string `json:"sha512,omitempty" yaml:"sha512,omitempty" ecs:"dll.hash.sha512"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b DLLHash) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.MD5); !val.IsZero() {
		res["md5"] = b.MD5
	}

	if val := reflect.ValueOf(b.SHA1); !val.IsZero() {
		res["sha1"] = b.SHA1
	}

	if val := reflect.ValueOf(b.SHA256); !val.IsZero() {
		res["sha256"] = b.SHA256
	}

	if val := reflect.ValueOf(b.SHA512); !val.IsZero() {
		res["sha512"] = b.SHA512
	}

	return json.Marshal(res)
}

// DLLPE defines the object located at ECS path dll.pe.
type DLLPE struct {
	Architecture     string `json:"architecture,omitempty" yaml:"architecture,omitempty" ecs:"dll.pe.architecture"`
	Company          string `json:"company,omitempty" yaml:"company,omitempty" ecs:"dll.pe.company"`
	Description      string `json:"description,omitempty" yaml:"description,omitempty" ecs:"dll.pe.description"`
	FileVersion      string `json:"file_version,omitempty" yaml:"file_version,omitempty" ecs:"dll.pe.file_version"`
	Imphash          string `json:"imphash,omitempty" yaml:"imphash,omitempty" ecs:"dll.pe.imphash"`
	OriginalFileName string `json:"original_file_name,omitempty" yaml:"original_file_name,omitempty" ecs:"dll.pe.original_file_name"`
	Product          string `json:"product,omitempty" yaml:"product,omitempty" ecs:"dll.pe.product"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b DLLPE) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Architecture); !val.IsZero() {
		res["architecture"] = b.Architecture
	}

	if val := reflect.ValueOf(b.Company); !val.IsZero() {
		res["company"] = b.Company
	}

	if val := reflect.ValueOf(b.Description); !val.IsZero() {
		res["description"] = b.Description
	}

	if val := reflect.ValueOf(b.FileVersion); !val.IsZero() {
		res["file_version"] = b.FileVersion
	}

	if val := reflect.ValueOf(b.Imphash); !val.IsZero() {
		res["imphash"] = b.Imphash
	}

	if val := reflect.ValueOf(b.OriginalFileName); !val.IsZero() {
		res["original_file_name"] = b.OriginalFileName
	}

	if val := reflect.ValueOf(b.Product); !val.IsZero() {
		res["product"] = b.Product
	}

	return json.Marshal(res)
}

// DNS defines the object located at ECS path dns.
type DNS struct {
	Answers      []DNSAnswers `json:"answers,omitempty" yaml:"answers,omitempty" ecs:"dns.answers"`
	HeaderFlags  []string     `json:"header_flags,omitempty" yaml:"header_flags,omitempty" ecs:"dns.header_flags"`
	ID           string       `json:"id,omitempty" yaml:"id,omitempty" ecs:"dns.id"`
	OpCode       string       `json:"op_code,omitempty" yaml:"op_code,omitempty" ecs:"dns.op_code"`
	Question     DNSQuestion  `json:"question,omitempty" yaml:"question,omitempty" ecs:"dns.question"`
	ResolvedIP   []string     `json:"resolved_ip,omitempty" yaml:"resolved_ip,omitempty" ecs:"dns.resolved_ip"`
	ResponseCode string       `json:"response_code,omitempty" yaml:"response_code,omitempty" ecs:"dns.response_code"`
	Type         string       `json:"type,omitempty" yaml:"type,omitempty" ecs:"dns.type"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b DNS) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Answers); !val.IsZero() {
		res["answers"] = b.Answers
	}

	if val := reflect.ValueOf(b.HeaderFlags); !val.IsZero() {
		res["header_flags"] = b.HeaderFlags
	}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.OpCode); !val.IsZero() {
		res["op_code"] = b.OpCode
	}

	if val := reflect.ValueOf(b.Question); !val.IsZero() {
		res["question"] = b.Question
	}

	if val := reflect.ValueOf(b.ResolvedIP); !val.IsZero() {
		res["resolved_ip"] = b.ResolvedIP
	}

	if val := reflect.ValueOf(b.ResponseCode); !val.IsZero() {
		res["response_code"] = b.ResponseCode
	}

	if val := reflect.ValueOf(b.Type); !val.IsZero() {
		res["type"] = b.Type
	}

	return json.Marshal(res)
}

// DNSAnswers defines the object located at ECS path dns.answers.
type DNSAnswers struct {
	Class string      `json:"class,omitempty" yaml:"class,omitempty" ecs:"dns.answers.class"`
	Data  string      `json:"data,omitempty" yaml:"data,omitempty" ecs:"dns.answers.data"`
	Name  string      `json:"name,omitempty" yaml:"name,omitempty" ecs:"dns.answers.name"`
	TTL   json.Number `json:"ttl,omitempty" yaml:"ttl,omitempty" ecs:"dns.answers.ttl"`
	Type  string      `json:"type,omitempty" yaml:"type,omitempty" ecs:"dns.answers.type"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b DNSAnswers) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Class); !val.IsZero() {
		res["class"] = b.Class
	}

	if val := reflect.ValueOf(b.Data); !val.IsZero() {
		res["data"] = b.Data
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	if val := reflect.ValueOf(b.TTL); !val.IsZero() {
		res["ttl"] = b.TTL
	}

	if val := reflect.ValueOf(b.Type); !val.IsZero() {
		res["type"] = b.Type
	}

	return json.Marshal(res)
}

// DNSQuestion defines the object located at ECS path dns.question.
type DNSQuestion struct {
	Class            string `json:"class,omitempty" yaml:"class,omitempty" ecs:"dns.question.class"`
	Name             string `json:"name,omitempty" yaml:"name,omitempty" ecs:"dns.question.name"`
	RegisteredDomain string `json:"registered_domain,omitempty" yaml:"registered_domain,omitempty" ecs:"dns.question.registered_domain"`
	Subdomain        string `json:"subdomain,omitempty" yaml:"subdomain,omitempty" ecs:"dns.question.subdomain"`
	TopLevelDomain   string `json:"top_level_domain,omitempty" yaml:"top_level_domain,omitempty" ecs:"dns.question.top_level_domain"`
	Type             string `json:"type,omitempty" yaml:"type,omitempty" ecs:"dns.question.type"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b DNSQuestion) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Class); !val.IsZero() {
		res["class"] = b.Class
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	if val := reflect.ValueOf(b.RegisteredDomain); !val.IsZero() {
		res["registered_domain"] = b.RegisteredDomain
	}

	if val := reflect.ValueOf(b.Subdomain); !val.IsZero() {
		res["subdomain"] = b.Subdomain
	}

	if val := reflect.ValueOf(b.TopLevelDomain); !val.IsZero() {
		res["top_level_domain"] = b.TopLevelDomain
	}

	if val := reflect.ValueOf(b.Type); !val.IsZero() {
		res["type"] = b.Type
	}

	return json.Marshal(res)
}

// ECS defines the object located at ECS path ecs.
type ECS struct {
	Version string `json:"version,omitempty" yaml:"version,omitempty" ecs:"ecs.version"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b ECS) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Version); !val.IsZero() {
		res["version"] = b.Version
	}

	return json.Marshal(res)
}

// Error defines the object located at ECS path error.
type Error struct {
	Code       string `json:"code,omitempty" yaml:"code,omitempty" ecs:"error.code"`
	ID         string `json:"id,omitempty" yaml:"id,omitempty" ecs:"error.id"`
	Message    string `json:"message,omitempty" yaml:"message,omitempty" ecs:"error.message"`
	StackTrace string `json:"stack_trace,omitempty" yaml:"stack_trace,omitempty" ecs:"error.stack_trace"`
	Type       string `json:"type,omitempty" yaml:"type,omitempty" ecs:"error.type"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b Error) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Code); !val.IsZero() {
		res["code"] = b.Code
	}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.Message); !val.IsZero() {
		res["message"] = b.Message
	}

	if val := reflect.ValueOf(b.StackTrace); !val.IsZero() {
		res["stack_trace"] = b.StackTrace
	}

	if val := reflect.ValueOf(b.Type); !val.IsZero() {
		res["type"] = b.Type
	}

	return json.Marshal(res)
}

// Event defines the object located at ECS path event.
type Event struct {
	Action        string        `json:"action,omitempty" yaml:"action,omitempty" ecs:"event.action"`
	Category      []string      `json:"category,omitempty" yaml:"category,omitempty" ecs:"event.category"`
	Code          string        `json:"code,omitempty" yaml:"code,omitempty" ecs:"event.code"`
	Created       time.Time     `json:"created,omitempty" yaml:"created,omitempty" ecs:"event.created"`
	Dataset       string        `json:"dataset,omitempty" yaml:"dataset,omitempty" ecs:"event.dataset"`
	Duration      time.Duration `json:"duration,omitempty" yaml:"duration,omitempty" ecs:"event.duration"`
	End           time.Time     `json:"end,omitempty" yaml:"end,omitempty" ecs:"event.end"`
	Hash          string        `json:"hash,omitempty" yaml:"hash,omitempty" ecs:"event.hash"`
	ID            string        `json:"id,omitempty" yaml:"id,omitempty" ecs:"event.id"`
	Ingested      time.Time     `json:"ingested,omitempty" yaml:"ingested,omitempty" ecs:"event.ingested"`
	Kind          string        `json:"kind,omitempty" yaml:"kind,omitempty" ecs:"event.kind"`
	Module        string        `json:"module,omitempty" yaml:"module,omitempty" ecs:"event.module"`
	Original      string        `json:"original,omitempty" yaml:"original,omitempty" ecs:"event.original"`
	Outcome       string        `json:"outcome,omitempty" yaml:"outcome,omitempty" ecs:"event.outcome"`
	Provider      string        `json:"provider,omitempty" yaml:"provider,omitempty" ecs:"event.provider"`
	Reason        string        `json:"reason,omitempty" yaml:"reason,omitempty" ecs:"event.reason"`
	Reference     string        `json:"reference,omitempty" yaml:"reference,omitempty" ecs:"event.reference"`
	RiskScore     json.Number   `json:"risk_score,omitempty" yaml:"risk_score,omitempty" ecs:"event.risk_score"`
	RiskScoreNorm json.Number   `json:"risk_score_norm,omitempty" yaml:"risk_score_norm,omitempty" ecs:"event.risk_score_norm"`
	Sequence      json.Number   `json:"sequence,omitempty" yaml:"sequence,omitempty" ecs:"event.sequence"`
	Severity      json.Number   `json:"severity,omitempty" yaml:"severity,omitempty" ecs:"event.severity"`
	Start         time.Time     `json:"start,omitempty" yaml:"start,omitempty" ecs:"event.start"`
	Timezone      string        `json:"timezone,omitempty" yaml:"timezone,omitempty" ecs:"event.timezone"`
	Type          []string      `json:"type,omitempty" yaml:"type,omitempty" ecs:"event.type"`
	URL           string        `json:"url,omitempty" yaml:"url,omitempty" ecs:"event.url"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b Event) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Action); !val.IsZero() {
		res["action"] = b.Action
	}

	if val := reflect.ValueOf(b.Category); !val.IsZero() {
		res["category"] = b.Category
	}

	if val := reflect.ValueOf(b.Code); !val.IsZero() {
		res["code"] = b.Code
	}

	if val := reflect.ValueOf(b.Created); !val.IsZero() {
		res["created"] = b.Created
	}

	if val := reflect.ValueOf(b.Dataset); !val.IsZero() {
		res["dataset"] = b.Dataset
	}

	if val := reflect.ValueOf(b.Duration); !val.IsZero() {
		res["duration"] = b.Duration
	}

	if val := reflect.ValueOf(b.End); !val.IsZero() {
		res["end"] = b.End
	}

	if val := reflect.ValueOf(b.Hash); !val.IsZero() {
		res["hash"] = b.Hash
	}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.Ingested); !val.IsZero() {
		res["ingested"] = b.Ingested
	}

	if val := reflect.ValueOf(b.Kind); !val.IsZero() {
		res["kind"] = b.Kind
	}

	if val := reflect.ValueOf(b.Module); !val.IsZero() {
		res["module"] = b.Module
	}

	if val := reflect.ValueOf(b.Original); !val.IsZero() {
		res["original"] = b.Original
	}

	if val := reflect.ValueOf(b.Outcome); !val.IsZero() {
		res["outcome"] = b.Outcome
	}

	if val := reflect.ValueOf(b.Provider); !val.IsZero() {
		res["provider"] = b.Provider
	}

	if val := reflect.ValueOf(b.Reason); !val.IsZero() {
		res["reason"] = b.Reason
	}

	if val := reflect.ValueOf(b.Reference); !val.IsZero() {
		res["reference"] = b.Reference
	}

	if val := reflect.ValueOf(b.RiskScore); !val.IsZero() {
		res["risk_score"] = b.RiskScore
	}

	if val := reflect.ValueOf(b.RiskScoreNorm); !val.IsZero() {
		res["risk_score_norm"] = b.RiskScoreNorm
	}

	if val := reflect.ValueOf(b.Sequence); !val.IsZero() {
		res["sequence"] = b.Sequence
	}

	if val := reflect.ValueOf(b.Severity); !val.IsZero() {
		res["severity"] = b.Severity
	}

	if val := reflect.ValueOf(b.Start); !val.IsZero() {
		res["start"] = b.Start
	}

	if val := reflect.ValueOf(b.Timezone); !val.IsZero() {
		res["timezone"] = b.Timezone
	}

	if val := reflect.ValueOf(b.Type); !val.IsZero() {
		res["type"] = b.Type
	}

	if val := reflect.ValueOf(b.URL); !val.IsZero() {
		res["url"] = b.URL
	}

	return JSONMarshalNoHTMLEscape(res)
}

// File defines the object located at ECS path file.
type File struct {
	Accessed      time.Time         `json:"accessed,omitempty" yaml:"accessed,omitempty" ecs:"file.accessed"`
	Attributes    []string          `json:"attributes,omitempty" yaml:"attributes,omitempty" ecs:"file.attributes"`
	CodeSignature FileCodeSignature `json:"code_signature,omitempty" yaml:"code_signature,omitempty" ecs:"file.code_signature"`
	Created       time.Time         `json:"created,omitempty" yaml:"created,omitempty" ecs:"file.created"`
	Ctime         time.Time         `json:"ctime,omitempty" yaml:"ctime,omitempty" ecs:"file.ctime"`
	Device        string            `json:"device,omitempty" yaml:"device,omitempty" ecs:"file.device"`
	Directory     string            `json:"directory,omitempty" yaml:"directory,omitempty" ecs:"file.directory"`
	DriveLetter   string            `json:"drive_letter,omitempty" yaml:"drive_letter,omitempty" ecs:"file.drive_letter"`
	Extension     string            `json:"extension,omitempty" yaml:"extension,omitempty" ecs:"file.extension"`
	Gid           string            `json:"gid,omitempty" yaml:"gid,omitempty" ecs:"file.gid"`
	Group         string            `json:"group,omitempty" yaml:"group,omitempty" ecs:"file.group"`
	Hash          FileHash          `json:"hash,omitempty" yaml:"hash,omitempty" ecs:"file.hash"`
	Inode         string            `json:"inode,omitempty" yaml:"inode,omitempty" ecs:"file.inode"`
	MIMEType      string            `json:"mime_type,omitempty" yaml:"mime_type,omitempty" ecs:"file.mime_type"`
	Mode          string            `json:"mode,omitempty" yaml:"mode,omitempty" ecs:"file.mode"`
	Mtime         time.Time         `json:"mtime,omitempty" yaml:"mtime,omitempty" ecs:"file.mtime"`
	Name          string            `json:"name,omitempty" yaml:"name,omitempty" ecs:"file.name"`
	Owner         string            `json:"owner,omitempty" yaml:"owner,omitempty" ecs:"file.owner"`
	Path          string            `json:"path,omitempty" yaml:"path,omitempty" ecs:"file.path"`
	PE            FilePE            `json:"pe,omitempty" yaml:"pe,omitempty" ecs:"file.pe"`
	Size          json.Number       `json:"size,omitempty" yaml:"size,omitempty" ecs:"file.size"`
	TargetPath    string            `json:"target_path,omitempty" yaml:"target_path,omitempty" ecs:"file.target_path"`
	Type          string            `json:"type,omitempty" yaml:"type,omitempty" ecs:"file.type"`
	UID           string            `json:"uid,omitempty" yaml:"uid,omitempty" ecs:"file.uid"`
	X509          FileX509          `json:"x509,omitempty" yaml:"x509,omitempty" ecs:"file.x509"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b File) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Accessed); !val.IsZero() {
		res["accessed"] = b.Accessed
	}

	if val := reflect.ValueOf(b.Attributes); !val.IsZero() {
		res["attributes"] = b.Attributes
	}

	if val := reflect.ValueOf(b.CodeSignature); !val.IsZero() {
		res["code_signature"] = b.CodeSignature
	}

	if val := reflect.ValueOf(b.Created); !val.IsZero() {
		res["created"] = b.Created
	}

	if val := reflect.ValueOf(b.Ctime); !val.IsZero() {
		res["ctime"] = b.Ctime
	}

	if val := reflect.ValueOf(b.Device); !val.IsZero() {
		res["device"] = b.Device
	}

	if val := reflect.ValueOf(b.Directory); !val.IsZero() {
		res["directory"] = b.Directory
	}

	if val := reflect.ValueOf(b.DriveLetter); !val.IsZero() {
		res["drive_letter"] = b.DriveLetter
	}

	if val := reflect.ValueOf(b.Extension); !val.IsZero() {
		res["extension"] = b.Extension
	}

	if val := reflect.ValueOf(b.Gid); !val.IsZero() {
		res["gid"] = b.Gid
	}

	if val := reflect.ValueOf(b.Group); !val.IsZero() {
		res["group"] = b.Group
	}

	if val := reflect.ValueOf(b.Hash); !val.IsZero() {
		res["hash"] = b.Hash
	}

	if val := reflect.ValueOf(b.Inode); !val.IsZero() {
		res["inode"] = b.Inode
	}

	if val := reflect.ValueOf(b.MIMEType); !val.IsZero() {
		res["mime_type"] = b.MIMEType
	}

	if val := reflect.ValueOf(b.Mode); !val.IsZero() {
		res["mode"] = b.Mode
	}

	if val := reflect.ValueOf(b.Mtime); !val.IsZero() {
		res["mtime"] = b.Mtime
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	if val := reflect.ValueOf(b.Owner); !val.IsZero() {
		res["owner"] = b.Owner
	}

	if val := reflect.ValueOf(b.Path); !val.IsZero() {
		res["path"] = b.Path
	}

	if val := reflect.ValueOf(b.PE); !val.IsZero() {
		res["pe"] = b.PE
	}

	if val := reflect.ValueOf(b.Size); !val.IsZero() {
		res["size"] = b.Size
	}

	if val := reflect.ValueOf(b.TargetPath); !val.IsZero() {
		res["target_path"] = b.TargetPath
	}

	if val := reflect.ValueOf(b.Type); !val.IsZero() {
		res["type"] = b.Type
	}

	if val := reflect.ValueOf(b.UID); !val.IsZero() {
		res["uid"] = b.UID
	}

	if val := reflect.ValueOf(b.X509); !val.IsZero() {
		res["x509"] = b.X509
	}

	return json.Marshal(res)
}

// FileCodeSignature defines the object located at ECS path file.code_signature.
type FileCodeSignature struct {
	Exists      bool   `json:"exists,omitempty" yaml:"exists,omitempty" ecs:"file.code_signature.exists"`
	Status      string `json:"status,omitempty" yaml:"status,omitempty" ecs:"file.code_signature.status"`
	SubjectName string `json:"subject_name,omitempty" yaml:"subject_name,omitempty" ecs:"file.code_signature.subject_name"`
	Trusted     bool   `json:"trusted,omitempty" yaml:"trusted,omitempty" ecs:"file.code_signature.trusted"`
	Valid       bool   `json:"valid,omitempty" yaml:"valid,omitempty" ecs:"file.code_signature.valid"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b FileCodeSignature) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Exists); !val.IsZero() {
		res["exists"] = b.Exists
	}

	if val := reflect.ValueOf(b.Status); !val.IsZero() {
		res["status"] = b.Status
	}

	if val := reflect.ValueOf(b.SubjectName); !val.IsZero() {
		res["subject_name"] = b.SubjectName
	}

	if val := reflect.ValueOf(b.Trusted); !val.IsZero() {
		res["trusted"] = b.Trusted
	}

	if val := reflect.ValueOf(b.Valid); !val.IsZero() {
		res["valid"] = b.Valid
	}

	return json.Marshal(res)
}

// FileHash defines the object located at ECS path file.hash.
type FileHash struct {
	MD5    string `json:"md5,omitempty" yaml:"md5,omitempty" ecs:"file.hash.md5"`
	SHA1   string `json:"sha1,omitempty" yaml:"sha1,omitempty" ecs:"file.hash.sha1"`
	SHA256 string `json:"sha256,omitempty" yaml:"sha256,omitempty" ecs:"file.hash.sha256"`
	SHA512 string `json:"sha512,omitempty" yaml:"sha512,omitempty" ecs:"file.hash.sha512"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b FileHash) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.MD5); !val.IsZero() {
		res["md5"] = b.MD5
	}

	if val := reflect.ValueOf(b.SHA1); !val.IsZero() {
		res["sha1"] = b.SHA1
	}

	if val := reflect.ValueOf(b.SHA256); !val.IsZero() {
		res["sha256"] = b.SHA256
	}

	if val := reflect.ValueOf(b.SHA512); !val.IsZero() {
		res["sha512"] = b.SHA512
	}

	return json.Marshal(res)
}

// FilePE defines the object located at ECS path file.pe.
type FilePE struct {
	Architecture     string `json:"architecture,omitempty" yaml:"architecture,omitempty" ecs:"file.pe.architecture"`
	Company          string `json:"company,omitempty" yaml:"company,omitempty" ecs:"file.pe.company"`
	Description      string `json:"description,omitempty" yaml:"description,omitempty" ecs:"file.pe.description"`
	FileVersion      string `json:"file_version,omitempty" yaml:"file_version,omitempty" ecs:"file.pe.file_version"`
	Imphash          string `json:"imphash,omitempty" yaml:"imphash,omitempty" ecs:"file.pe.imphash"`
	OriginalFileName string `json:"original_file_name,omitempty" yaml:"original_file_name,omitempty" ecs:"file.pe.original_file_name"`
	Product          string `json:"product,omitempty" yaml:"product,omitempty" ecs:"file.pe.product"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b FilePE) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Architecture); !val.IsZero() {
		res["architecture"] = b.Architecture
	}

	if val := reflect.ValueOf(b.Company); !val.IsZero() {
		res["company"] = b.Company
	}

	if val := reflect.ValueOf(b.Description); !val.IsZero() {
		res["description"] = b.Description
	}

	if val := reflect.ValueOf(b.FileVersion); !val.IsZero() {
		res["file_version"] = b.FileVersion
	}

	if val := reflect.ValueOf(b.Imphash); !val.IsZero() {
		res["imphash"] = b.Imphash
	}

	if val := reflect.ValueOf(b.OriginalFileName); !val.IsZero() {
		res["original_file_name"] = b.OriginalFileName
	}

	if val := reflect.ValueOf(b.Product); !val.IsZero() {
		res["product"] = b.Product
	}

	return json.Marshal(res)
}

// FileX509 defines the object located at ECS path file.x509.
type FileX509 struct {
	AlternativeNames   []string        `json:"alternative_names,omitempty" yaml:"alternative_names,omitempty" ecs:"file.x509.alternative_names"`
	Issuer             FileX509Issuer  `json:"issuer,omitempty" yaml:"issuer,omitempty" ecs:"file.x509.issuer"`
	NotAfter           time.Time       `json:"not_after,omitempty" yaml:"not_after,omitempty" ecs:"file.x509.not_after"`
	NotBefore          time.Time       `json:"not_before,omitempty" yaml:"not_before,omitempty" ecs:"file.x509.not_before"`
	PublicKeyAlgorithm string          `json:"public_key_algorithm,omitempty" yaml:"public_key_algorithm,omitempty" ecs:"file.x509.public_key_algorithm"`
	PublicKeyCurve     string          `json:"public_key_curve,omitempty" yaml:"public_key_curve,omitempty" ecs:"file.x509.public_key_curve"`
	PublicKeyExponent  json.Number     `json:"public_key_exponent,omitempty" yaml:"public_key_exponent,omitempty" ecs:"file.x509.public_key_exponent"`
	PublicKeySize      json.Number     `json:"public_key_size,omitempty" yaml:"public_key_size,omitempty" ecs:"file.x509.public_key_size"`
	SerialNumber       string          `json:"serial_number,omitempty" yaml:"serial_number,omitempty" ecs:"file.x509.serial_number"`
	SignatureAlgorithm string          `json:"signature_algorithm,omitempty" yaml:"signature_algorithm,omitempty" ecs:"file.x509.signature_algorithm"`
	Subject            FileX509Subject `json:"subject,omitempty" yaml:"subject,omitempty" ecs:"file.x509.subject"`
	VersionNumber      string          `json:"version_number,omitempty" yaml:"version_number,omitempty" ecs:"file.x509.version_number"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b FileX509) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.AlternativeNames); !val.IsZero() {
		res["alternative_names"] = b.AlternativeNames
	}

	if val := reflect.ValueOf(b.Issuer); !val.IsZero() {
		res["issuer"] = b.Issuer
	}

	if val := reflect.ValueOf(b.NotAfter); !val.IsZero() {
		res["not_after"] = b.NotAfter
	}

	if val := reflect.ValueOf(b.NotBefore); !val.IsZero() {
		res["not_before"] = b.NotBefore
	}

	if val := reflect.ValueOf(b.PublicKeyAlgorithm); !val.IsZero() {
		res["public_key_algorithm"] = b.PublicKeyAlgorithm
	}

	if val := reflect.ValueOf(b.PublicKeyCurve); !val.IsZero() {
		res["public_key_curve"] = b.PublicKeyCurve
	}

	if val := reflect.ValueOf(b.PublicKeyExponent); !val.IsZero() {
		res["public_key_exponent"] = b.PublicKeyExponent
	}

	if val := reflect.ValueOf(b.PublicKeySize); !val.IsZero() {
		res["public_key_size"] = b.PublicKeySize
	}

	if val := reflect.ValueOf(b.SerialNumber); !val.IsZero() {
		res["serial_number"] = b.SerialNumber
	}

	if val := reflect.ValueOf(b.SignatureAlgorithm); !val.IsZero() {
		res["signature_algorithm"] = b.SignatureAlgorithm
	}

	if val := reflect.ValueOf(b.Subject); !val.IsZero() {
		res["subject"] = b.Subject
	}

	if val := reflect.ValueOf(b.VersionNumber); !val.IsZero() {
		res["version_number"] = b.VersionNumber
	}

	return json.Marshal(res)
}

// FileX509Issuer defines the object located at ECS path file.x509.issuer.
type FileX509Issuer struct {
	CommonName         []string `json:"common_name,omitempty" yaml:"common_name,omitempty" ecs:"file.x509.issuer.common_name"`
	Country            []string `json:"country,omitempty" yaml:"country,omitempty" ecs:"file.x509.issuer.country"`
	DistinguishedName  string   `json:"distinguished_name,omitempty" yaml:"distinguished_name,omitempty" ecs:"file.x509.issuer.distinguished_name"`
	Locality           []string `json:"locality,omitempty" yaml:"locality,omitempty" ecs:"file.x509.issuer.locality"`
	Organization       []string `json:"organization,omitempty" yaml:"organization,omitempty" ecs:"file.x509.issuer.organization"`
	OrganizationalUnit []string `json:"organizational_unit,omitempty" yaml:"organizational_unit,omitempty" ecs:"file.x509.issuer.organizational_unit"`
	StateOrProvince    []string `json:"state_or_province,omitempty" yaml:"state_or_province,omitempty" ecs:"file.x509.issuer.state_or_province"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b FileX509Issuer) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.CommonName); !val.IsZero() {
		res["common_name"] = b.CommonName
	}

	if val := reflect.ValueOf(b.Country); !val.IsZero() {
		res["country"] = b.Country
	}

	if val := reflect.ValueOf(b.DistinguishedName); !val.IsZero() {
		res["distinguished_name"] = b.DistinguishedName
	}

	if val := reflect.ValueOf(b.Locality); !val.IsZero() {
		res["locality"] = b.Locality
	}

	if val := reflect.ValueOf(b.Organization); !val.IsZero() {
		res["organization"] = b.Organization
	}

	if val := reflect.ValueOf(b.OrganizationalUnit); !val.IsZero() {
		res["organizational_unit"] = b.OrganizationalUnit
	}

	if val := reflect.ValueOf(b.StateOrProvince); !val.IsZero() {
		res["state_or_province"] = b.StateOrProvince
	}

	return json.Marshal(res)
}

// FileX509Subject defines the object located at ECS path file.x509.subject.
type FileX509Subject struct {
	CommonName         []string `json:"common_name,omitempty" yaml:"common_name,omitempty" ecs:"file.x509.subject.common_name"`
	Country            []string `json:"country,omitempty" yaml:"country,omitempty" ecs:"file.x509.subject.country"`
	DistinguishedName  string   `json:"distinguished_name,omitempty" yaml:"distinguished_name,omitempty" ecs:"file.x509.subject.distinguished_name"`
	Locality           []string `json:"locality,omitempty" yaml:"locality,omitempty" ecs:"file.x509.subject.locality"`
	Organization       []string `json:"organization,omitempty" yaml:"organization,omitempty" ecs:"file.x509.subject.organization"`
	OrganizationalUnit []string `json:"organizational_unit,omitempty" yaml:"organizational_unit,omitempty" ecs:"file.x509.subject.organizational_unit"`
	StateOrProvince    []string `json:"state_or_province,omitempty" yaml:"state_or_province,omitempty" ecs:"file.x509.subject.state_or_province"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b FileX509Subject) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.CommonName); !val.IsZero() {
		res["common_name"] = b.CommonName
	}

	if val := reflect.ValueOf(b.Country); !val.IsZero() {
		res["country"] = b.Country
	}

	if val := reflect.ValueOf(b.DistinguishedName); !val.IsZero() {
		res["distinguished_name"] = b.DistinguishedName
	}

	if val := reflect.ValueOf(b.Locality); !val.IsZero() {
		res["locality"] = b.Locality
	}

	if val := reflect.ValueOf(b.Organization); !val.IsZero() {
		res["organization"] = b.Organization
	}

	if val := reflect.ValueOf(b.OrganizationalUnit); !val.IsZero() {
		res["organizational_unit"] = b.OrganizationalUnit
	}

	if val := reflect.ValueOf(b.StateOrProvince); !val.IsZero() {
		res["state_or_province"] = b.StateOrProvince
	}

	return json.Marshal(res)
}

// Group defines the object located at ECS path group.
type Group struct {
	Domain string `json:"domain,omitempty" yaml:"domain,omitempty" ecs:"group.domain"`
	ID     string `json:"id,omitempty" yaml:"id,omitempty" ecs:"group.id"`
	Name   string `json:"name,omitempty" yaml:"name,omitempty" ecs:"group.name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b Group) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Domain); !val.IsZero() {
		res["domain"] = b.Domain
	}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	return json.Marshal(res)
}

// Host defines the object located at ECS path host.
type Host struct {
	Architecture string      `json:"architecture,omitempty" yaml:"architecture,omitempty" ecs:"host.architecture"`
	Domain       string      `json:"domain,omitempty" yaml:"domain,omitempty" ecs:"host.domain"`
	Geo          HostGeo     `json:"geo,omitempty" yaml:"geo,omitempty" ecs:"host.geo"`
	Hostname     string      `json:"hostname,omitempty" yaml:"hostname,omitempty" ecs:"host.hostname"`
	ID           string      `json:"id,omitempty" yaml:"id,omitempty" ecs:"host.id"`
	IP           []string    `json:"ip,omitempty" yaml:"ip,omitempty" ecs:"host.ip"`
	MAC          []string    `json:"mac,omitempty" yaml:"mac,omitempty" ecs:"host.mac"`
	Name         string      `json:"name,omitempty" yaml:"name,omitempty" ecs:"host.name"`
	OS           HostOS      `json:"os,omitempty" yaml:"os,omitempty" ecs:"host.os"`
	Type         string      `json:"type,omitempty" yaml:"type,omitempty" ecs:"host.type"`
	Uptime       json.Number `json:"uptime,omitempty" yaml:"uptime,omitempty" ecs:"host.uptime"`
	User         HostUser    `json:"user,omitempty" yaml:"user,omitempty" ecs:"host.user"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b Host) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Architecture); !val.IsZero() {
		res["architecture"] = b.Architecture
	}

	if val := reflect.ValueOf(b.Domain); !val.IsZero() {
		res["domain"] = b.Domain
	}

	if val := reflect.ValueOf(b.Geo); !val.IsZero() {
		res["geo"] = b.Geo
	}

	if val := reflect.ValueOf(b.Hostname); !val.IsZero() {
		res["hostname"] = b.Hostname
	}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.IP); !val.IsZero() {
		res["ip"] = b.IP
	}

	if val := reflect.ValueOf(b.MAC); !val.IsZero() {
		res["mac"] = b.MAC
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	if val := reflect.ValueOf(b.OS); !val.IsZero() {
		res["os"] = b.OS
	}

	if val := reflect.ValueOf(b.Type); !val.IsZero() {
		res["type"] = b.Type
	}

	if val := reflect.ValueOf(b.Uptime); !val.IsZero() {
		res["uptime"] = b.Uptime
	}

	if val := reflect.ValueOf(b.User); !val.IsZero() {
		res["user"] = b.User
	}

	return json.Marshal(res)
}

// HostGeo defines the object located at ECS path host.geo.
type HostGeo struct {
	CityName       string       `json:"city_name,omitempty" yaml:"city_name,omitempty" ecs:"host.geo.city_name"`
	ContinentName  string       `json:"continent_name,omitempty" yaml:"continent_name,omitempty" ecs:"host.geo.continent_name"`
	CountryISOCode string       `json:"country_iso_code,omitempty" yaml:"country_iso_code,omitempty" ecs:"host.geo.country_iso_code"`
	CountryName    string       `json:"country_name,omitempty" yaml:"country_name,omitempty" ecs:"host.geo.country_name"`
	Location       HostGeoPoint `json:"location,omitempty" yaml:"location,omitempty" ecs:"host.geo.location"`
	Name           string       `json:"name,omitempty" yaml:"name,omitempty" ecs:"host.geo.name"`
	RegionISOCode  string       `json:"region_iso_code,omitempty" yaml:"region_iso_code,omitempty" ecs:"host.geo.region_iso_code"`
	RegionName     string       `json:"region_name,omitempty" yaml:"region_name,omitempty" ecs:"host.geo.region_name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b HostGeo) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.CityName); !val.IsZero() {
		res["city_name"] = b.CityName
	}

	if val := reflect.ValueOf(b.ContinentName); !val.IsZero() {
		res["continent_name"] = b.ContinentName
	}

	if val := reflect.ValueOf(b.CountryISOCode); !val.IsZero() {
		res["country_iso_code"] = b.CountryISOCode
	}

	if val := reflect.ValueOf(b.CountryName); !val.IsZero() {
		res["country_name"] = b.CountryName
	}

	if val := reflect.ValueOf(b.Location); !val.IsZero() {
		res["location"] = b.Location
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	if val := reflect.ValueOf(b.RegionISOCode); !val.IsZero() {
		res["region_iso_code"] = b.RegionISOCode
	}

	if val := reflect.ValueOf(b.RegionName); !val.IsZero() {
		res["region_name"] = b.RegionName
	}

	return json.Marshal(res)
}

// GeoPoint defines the object at ECS path host.geo.location
type HostGeoPoint struct {
	Latitude  json.Number `json:"lat,omitempty" yaml:"lat,omitempty" ecs:"host.geo.location.lat"`
	Longitude json.Number `json:"lon,omitempty" yaml:"lon,omitempty" ecs:"host.geo.location.lon"`
}

func (b HostGeoPoint) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Latitude); !val.IsZero() {
		res["lat"] = b.Latitude
	}

	if val := reflect.ValueOf(b.Longitude); !val.IsZero() {
		res["lon"] = b.Longitude
	}

	return json.Marshal(res)
}

// HostOS defines the object located at ECS path host.os.
type HostOS struct {
	Family   string `json:"family,omitempty" yaml:"family,omitempty" ecs:"host.os.family"`
	Full     string `json:"full,omitempty" yaml:"full,omitempty" ecs:"host.os.full"`
	Kernel   string `json:"kernel,omitempty" yaml:"kernel,omitempty" ecs:"host.os.kernel"`
	Name     string `json:"name,omitempty" yaml:"name,omitempty" ecs:"host.os.name"`
	Platform string `json:"platform,omitempty" yaml:"platform,omitempty" ecs:"host.os.platform"`
	Version  string `json:"version,omitempty" yaml:"version,omitempty" ecs:"host.os.version"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b HostOS) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Family); !val.IsZero() {
		res["family"] = b.Family
	}

	if val := reflect.ValueOf(b.Full); !val.IsZero() {
		res["full"] = b.Full
	}

	if val := reflect.ValueOf(b.Kernel); !val.IsZero() {
		res["kernel"] = b.Kernel
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	if val := reflect.ValueOf(b.Platform); !val.IsZero() {
		res["platform"] = b.Platform
	}

	if val := reflect.ValueOf(b.Version); !val.IsZero() {
		res["version"] = b.Version
	}

	return json.Marshal(res)
}

// HostUser defines the object located at ECS path host.user.
type HostUser struct {
	Domain   string        `json:"domain,omitempty" yaml:"domain,omitempty" ecs:"host.user.domain"`
	Email    string        `json:"email,omitempty" yaml:"email,omitempty" ecs:"host.user.email"`
	FullName string        `json:"full_name,omitempty" yaml:"full_name,omitempty" ecs:"host.user.full_name"`
	Group    HostUserGroup `json:"group,omitempty" yaml:"group,omitempty" ecs:"host.user.group"`
	Hash     string        `json:"hash,omitempty" yaml:"hash,omitempty" ecs:"host.user.hash"`
	ID       string        `json:"id,omitempty" yaml:"id,omitempty" ecs:"host.user.id"`
	Name     string        `json:"name,omitempty" yaml:"name,omitempty" ecs:"host.user.name"`
	Roles    []string      `json:"roles,omitempty" yaml:"roles,omitempty" ecs:"host.user.roles"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b HostUser) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Domain); !val.IsZero() {
		res["domain"] = b.Domain
	}

	if val := reflect.ValueOf(b.Email); !val.IsZero() {
		res["email"] = b.Email
	}

	if val := reflect.ValueOf(b.FullName); !val.IsZero() {
		res["full_name"] = b.FullName
	}

	if val := reflect.ValueOf(b.Group); !val.IsZero() {
		res["group"] = b.Group
	}

	if val := reflect.ValueOf(b.Hash); !val.IsZero() {
		res["hash"] = b.Hash
	}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	if val := reflect.ValueOf(b.Roles); !val.IsZero() {
		res["roles"] = b.Roles
	}

	return json.Marshal(res)
}

// HostUserGroup defines the object located at ECS path host.user.group.
type HostUserGroup struct {
	Domain string `json:"domain,omitempty" yaml:"domain,omitempty" ecs:"host.user.group.domain"`
	ID     string `json:"id,omitempty" yaml:"id,omitempty" ecs:"host.user.group.id"`
	Name   string `json:"name,omitempty" yaml:"name,omitempty" ecs:"host.user.group.name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b HostUserGroup) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Domain); !val.IsZero() {
		res["domain"] = b.Domain
	}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	return json.Marshal(res)
}

// HTTP defines the object located at ECS path http.
type HTTP struct {
	Request  HTTPRequest  `json:"request,omitempty" yaml:"request,omitempty" ecs:"http.request"`
	Response HTTPResponse `json:"response,omitempty" yaml:"response,omitempty" ecs:"http.response"`
	Version  string       `json:"version,omitempty" yaml:"version,omitempty" ecs:"http.version"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b HTTP) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Request); !val.IsZero() {
		res["request"] = b.Request
	}

	if val := reflect.ValueOf(b.Response); !val.IsZero() {
		res["response"] = b.Response
	}

	if val := reflect.ValueOf(b.Version); !val.IsZero() {
		res["version"] = b.Version
	}

	return json.Marshal(res)
}

// HTTPRequest defines the object located at ECS path http.request.
type HTTPRequest struct {
	Body     HTTPRequestBody `json:"body,omitempty" yaml:"body,omitempty" ecs:"http.request.body"`
	Bytes    json.Number     `json:"bytes,omitempty" yaml:"bytes,omitempty" ecs:"http.request.bytes"`
	Method   string          `json:"method,omitempty" yaml:"method,omitempty" ecs:"http.request.method"`
	Referrer string          `json:"referrer,omitempty" yaml:"referrer,omitempty" ecs:"http.request.referrer"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b HTTPRequest) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Body); !val.IsZero() {
		res["body"] = b.Body
	}

	if val := reflect.ValueOf(b.Bytes); !val.IsZero() {
		res["bytes"] = b.Bytes
	}

	if val := reflect.ValueOf(b.Method); !val.IsZero() {
		res["method"] = b.Method
	}

	if val := reflect.ValueOf(b.Referrer); !val.IsZero() {
		res["referrer"] = b.Referrer
	}

	return json.Marshal(res)
}

// HTTPRequestBody defines the object located at ECS path http.request.body.
type HTTPRequestBody struct {
	Bytes   json.Number `json:"bytes,omitempty" yaml:"bytes,omitempty" ecs:"http.request.body.bytes"`
	Content string      `json:"content,omitempty" yaml:"content,omitempty" ecs:"http.request.body.content"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b HTTPRequestBody) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Bytes); !val.IsZero() {
		res["bytes"] = b.Bytes
	}

	if val := reflect.ValueOf(b.Content); !val.IsZero() {
		res["content"] = b.Content
	}

	return json.Marshal(res)
}

// HTTPResponse defines the object located at ECS path http.response.
type HTTPResponse struct {
	Body       HTTPResponseBody `json:"body,omitempty" yaml:"body,omitempty" ecs:"http.response.body"`
	Bytes      json.Number      `json:"bytes,omitempty" yaml:"bytes,omitempty" ecs:"http.response.bytes"`
	StatusCode json.Number      `json:"status_code,omitempty" yaml:"status_code,omitempty" ecs:"http.response.status_code"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b HTTPResponse) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Body); !val.IsZero() {
		res["body"] = b.Body
	}

	if val := reflect.ValueOf(b.Bytes); !val.IsZero() {
		res["bytes"] = b.Bytes
	}

	if val := reflect.ValueOf(b.StatusCode); !val.IsZero() {
		res["status_code"] = b.StatusCode
	}

	return json.Marshal(res)
}

// HTTPResponseBody defines the object located at ECS path http.response.body.
type HTTPResponseBody struct {
	Bytes   json.Number `json:"bytes,omitempty" yaml:"bytes,omitempty" ecs:"http.response.body.bytes"`
	Content string      `json:"content,omitempty" yaml:"content,omitempty" ecs:"http.response.body.content"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b HTTPResponseBody) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Bytes); !val.IsZero() {
		res["bytes"] = b.Bytes
	}

	if val := reflect.ValueOf(b.Content); !val.IsZero() {
		res["content"] = b.Content
	}

	return json.Marshal(res)
}

// Log defines the object located at ECS path log.
type Log struct {
	File     LogFile   `json:"file,omitempty" yaml:"file,omitempty" ecs:"log.file"`
	Level    string    `json:"level,omitempty" yaml:"level,omitempty" ecs:"log.level"`
	Logger   string    `json:"logger,omitempty" yaml:"logger,omitempty" ecs:"log.logger"`
	Origin   LogOrigin `json:"origin,omitempty" yaml:"origin,omitempty" ecs:"log.origin"`
	Original string    `json:"original,omitempty" yaml:"original,omitempty" ecs:"log.original"`
	Syslog   LogSyslog `json:"syslog,omitempty" yaml:"syslog,omitempty" ecs:"log.syslog"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b Log) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.File); !val.IsZero() {
		res["file"] = b.File
	}

	if val := reflect.ValueOf(b.Level); !val.IsZero() {
		res["level"] = b.Level
	}

	if val := reflect.ValueOf(b.Logger); !val.IsZero() {
		res["logger"] = b.Logger
	}

	if val := reflect.ValueOf(b.Origin); !val.IsZero() {
		res["origin"] = b.Origin
	}

	if val := reflect.ValueOf(b.Original); !val.IsZero() {
		res["original"] = b.Original
	}

	if val := reflect.ValueOf(b.Syslog); !val.IsZero() {
		res["syslog"] = b.Syslog
	}

	return json.Marshal(res)
}

// LogFile defines the object located at ECS path log.file.
type LogFile struct {
	Path string `json:"path,omitempty" yaml:"path,omitempty" ecs:"log.file.path"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b LogFile) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Path); !val.IsZero() {
		res["path"] = b.Path
	}

	return json.Marshal(res)
}

// LogOrigin defines the object located at ECS path log.origin.
type LogOrigin struct {
	File     LogOriginFile `json:"file,omitempty" yaml:"file,omitempty" ecs:"log.origin.file"`
	Function string        `json:"function,omitempty" yaml:"function,omitempty" ecs:"log.origin.function"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b LogOrigin) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.File); !val.IsZero() {
		res["file"] = b.File
	}

	if val := reflect.ValueOf(b.Function); !val.IsZero() {
		res["function"] = b.Function
	}

	return json.Marshal(res)
}

// LogOriginFile defines the object located at ECS path log.origin.file.
type LogOriginFile struct {
	Line json.Number `json:"line,omitempty" yaml:"line,omitempty" ecs:"log.origin.file.line"`
	Name string      `json:"name,omitempty" yaml:"name,omitempty" ecs:"log.origin.file.name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b LogOriginFile) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Line); !val.IsZero() {
		res["line"] = b.Line
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	return json.Marshal(res)
}

// LogSyslog defines the object located at ECS path log.syslog.
type LogSyslog struct {
	Facility LogSyslogFacility `json:"facility,omitempty" yaml:"facility,omitempty" ecs:"log.syslog.facility"`
	Priority json.Number       `json:"priority,omitempty" yaml:"priority,omitempty" ecs:"log.syslog.priority"`
	Severity LogSyslogSeverity `json:"severity,omitempty" yaml:"severity,omitempty" ecs:"log.syslog.severity"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b LogSyslog) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Facility); !val.IsZero() {
		res["facility"] = b.Facility
	}

	if val := reflect.ValueOf(b.Priority); !val.IsZero() {
		res["priority"] = b.Priority
	}

	if val := reflect.ValueOf(b.Severity); !val.IsZero() {
		res["severity"] = b.Severity
	}

	return json.Marshal(res)
}

// LogSyslogFacility defines the object located at ECS path log.syslog.facility.
type LogSyslogFacility struct {
	Code json.Number `json:"code,omitempty" yaml:"code,omitempty" ecs:"log.syslog.facility.code"`
	Name string      `json:"name,omitempty" yaml:"name,omitempty" ecs:"log.syslog.facility.name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b LogSyslogFacility) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Code); !val.IsZero() {
		res["code"] = b.Code
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	return json.Marshal(res)
}

// LogSyslogSeverity defines the object located at ECS path log.syslog.severity.
type LogSyslogSeverity struct {
	Code json.Number `json:"code,omitempty" yaml:"code,omitempty" ecs:"log.syslog.severity.code"`
	Name string      `json:"name,omitempty" yaml:"name,omitempty" ecs:"log.syslog.severity.name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b LogSyslogSeverity) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Code); !val.IsZero() {
		res["code"] = b.Code
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	return json.Marshal(res)
}

// Network defines the object located at ECS path network.
type Network struct {
	Application string       `json:"application,omitempty" yaml:"application,omitempty" ecs:"network.application"`
	Bytes       json.Number  `json:"bytes,omitempty" yaml:"bytes,omitempty" ecs:"network.bytes"`
	CommunityID string       `json:"community_id,omitempty" yaml:"community_id,omitempty" ecs:"network.community_id"`
	Direction   string       `json:"direction,omitempty" yaml:"direction,omitempty" ecs:"network.direction"`
	ForwardedIP string       `json:"forwarded_ip,omitempty" yaml:"forwarded_ip,omitempty" ecs:"network.forwarded_ip"`
	IANANumber  string       `json:"iana_number,omitempty" yaml:"iana_number,omitempty" ecs:"network.iana_number"`
	Inner       NetworkInner `json:"inner,omitempty" yaml:"inner,omitempty" ecs:"network.inner"`
	Name        string       `json:"name,omitempty" yaml:"name,omitempty" ecs:"network.name"`
	Packets     json.Number  `json:"packets,omitempty" yaml:"packets,omitempty" ecs:"network.packets"`
	Protocol    string       `json:"protocol,omitempty" yaml:"protocol,omitempty" ecs:"network.protocol"`
	Transport   string       `json:"transport,omitempty" yaml:"transport,omitempty" ecs:"network.transport"`
	Type        string       `json:"type,omitempty" yaml:"type,omitempty" ecs:"network.type"`
	VLAN        NetworkVLAN  `json:"vlan,omitempty" yaml:"vlan,omitempty" ecs:"network.vlan"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b Network) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Application); !val.IsZero() {
		res["application"] = b.Application
	}

	if val := reflect.ValueOf(b.Bytes); !val.IsZero() {
		res["bytes"] = b.Bytes
	}

	if val := reflect.ValueOf(b.CommunityID); !val.IsZero() {
		res["community_id"] = b.CommunityID
	}

	if val := reflect.ValueOf(b.Direction); !val.IsZero() {
		res["direction"] = b.Direction
	}

	if val := reflect.ValueOf(b.ForwardedIP); !val.IsZero() {
		res["forwarded_ip"] = b.ForwardedIP
	}

	if val := reflect.ValueOf(b.IANANumber); !val.IsZero() {
		res["iana_number"] = b.IANANumber
	}

	if val := reflect.ValueOf(b.Inner); !val.IsZero() {
		res["inner"] = b.Inner
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	if val := reflect.ValueOf(b.Packets); !val.IsZero() {
		res["packets"] = b.Packets
	}

	if val := reflect.ValueOf(b.Protocol); !val.IsZero() {
		res["protocol"] = b.Protocol
	}

	if val := reflect.ValueOf(b.Transport); !val.IsZero() {
		res["transport"] = b.Transport
	}

	if val := reflect.ValueOf(b.Type); !val.IsZero() {
		res["type"] = b.Type
	}

	if val := reflect.ValueOf(b.VLAN); !val.IsZero() {
		res["vlan"] = b.VLAN
	}

	return json.Marshal(res)
}

// NetworkInner defines the object located at ECS path network.inner.
type NetworkInner struct {
	VLAN NetworkInnerVLAN `json:"vlan,omitempty" yaml:"vlan,omitempty" ecs:"network.inner.vlan"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b NetworkInner) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.VLAN); !val.IsZero() {
		res["vlan"] = b.VLAN
	}

	return json.Marshal(res)
}

// NetworkInnerVLAN defines the object located at ECS path network.inner.vlan.
type NetworkInnerVLAN struct {
	ID   string `json:"id,omitempty" yaml:"id,omitempty" ecs:"network.inner.vlan.id"`
	Name string `json:"name,omitempty" yaml:"name,omitempty" ecs:"network.inner.vlan.name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b NetworkInnerVLAN) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	return json.Marshal(res)
}

// NetworkVLAN defines the object located at ECS path network.vlan.
type NetworkVLAN struct {
	ID   string `json:"id,omitempty" yaml:"id,omitempty" ecs:"network.vlan.id"`
	Name string `json:"name,omitempty" yaml:"name,omitempty" ecs:"network.vlan.name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b NetworkVLAN) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	return json.Marshal(res)
}

// Observer defines the object located at ECS path observer.
type Observer struct {
	Egress       ObserverEgress  `json:"egress,omitempty" yaml:"egress,omitempty" ecs:"observer.egress"`
	Geo          ObserverGeo     `json:"geo,omitempty" yaml:"geo,omitempty" ecs:"observer.geo"`
	Hostname     string          `json:"hostname,omitempty" yaml:"hostname,omitempty" ecs:"observer.hostname"`
	Ingress      ObserverIngress `json:"ingress,omitempty" yaml:"ingress,omitempty" ecs:"observer.ingress"`
	IP           []string        `json:"ip,omitempty" yaml:"ip,omitempty" ecs:"observer.ip"`
	MAC          []string        `json:"mac,omitempty" yaml:"mac,omitempty" ecs:"observer.mac"`
	Name         string          `json:"name,omitempty" yaml:"name,omitempty" ecs:"observer.name"`
	OS           ObserverOS      `json:"os,omitempty" yaml:"os,omitempty" ecs:"observer.os"`
	Product      string          `json:"product,omitempty" yaml:"product,omitempty" ecs:"observer.product"`
	SerialNumber string          `json:"serial_number,omitempty" yaml:"serial_number,omitempty" ecs:"observer.serial_number"`
	Type         string          `json:"type,omitempty" yaml:"type,omitempty" ecs:"observer.type"`
	Vendor       string          `json:"vendor,omitempty" yaml:"vendor,omitempty" ecs:"observer.vendor"`
	Version      string          `json:"version,omitempty" yaml:"version,omitempty" ecs:"observer.version"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b Observer) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Egress); !val.IsZero() {
		res["egress"] = b.Egress
	}

	if val := reflect.ValueOf(b.Geo); !val.IsZero() {
		res["geo"] = b.Geo
	}

	if val := reflect.ValueOf(b.Hostname); !val.IsZero() {
		res["hostname"] = b.Hostname
	}

	if val := reflect.ValueOf(b.Ingress); !val.IsZero() {
		res["ingress"] = b.Ingress
	}

	if val := reflect.ValueOf(b.IP); !val.IsZero() {
		res["ip"] = b.IP
	}

	if val := reflect.ValueOf(b.MAC); !val.IsZero() {
		res["mac"] = b.MAC
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	if val := reflect.ValueOf(b.OS); !val.IsZero() {
		res["os"] = b.OS
	}

	if val := reflect.ValueOf(b.Product); !val.IsZero() {
		res["product"] = b.Product
	}

	if val := reflect.ValueOf(b.SerialNumber); !val.IsZero() {
		res["serial_number"] = b.SerialNumber
	}

	if val := reflect.ValueOf(b.Type); !val.IsZero() {
		res["type"] = b.Type
	}

	if val := reflect.ValueOf(b.Vendor); !val.IsZero() {
		res["vendor"] = b.Vendor
	}

	if val := reflect.ValueOf(b.Version); !val.IsZero() {
		res["version"] = b.Version
	}

	return json.Marshal(res)
}

// ObserverEgress defines the object located at ECS path observer.egress.
type ObserverEgress struct {
	Interface ObserverEgressInterface `json:"interface,omitempty" yaml:"interface,omitempty" ecs:"observer.egress.interface"`
	VLAN      ObserverEgressVLAN      `json:"vlan,omitempty" yaml:"vlan,omitempty" ecs:"observer.egress.vlan"`
	Zone      string                  `json:"zone,omitempty" yaml:"zone,omitempty" ecs:"observer.egress.zone"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b ObserverEgress) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Interface); !val.IsZero() {
		res["interface"] = b.Interface
	}

	if val := reflect.ValueOf(b.VLAN); !val.IsZero() {
		res["vlan"] = b.VLAN
	}

	if val := reflect.ValueOf(b.Zone); !val.IsZero() {
		res["zone"] = b.Zone
	}

	return json.Marshal(res)
}

// ObserverEgressInterface defines the object located at ECS path observer.egress.interface.
type ObserverEgressInterface struct {
	Alias string `json:"alias,omitempty" yaml:"alias,omitempty" ecs:"observer.egress.interface.alias"`
	ID    string `json:"id,omitempty" yaml:"id,omitempty" ecs:"observer.egress.interface.id"`
	Name  string `json:"name,omitempty" yaml:"name,omitempty" ecs:"observer.egress.interface.name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b ObserverEgressInterface) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Alias); !val.IsZero() {
		res["alias"] = b.Alias
	}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	return json.Marshal(res)
}

// ObserverEgressVLAN defines the object located at ECS path observer.egress.vlan.
type ObserverEgressVLAN struct {
	ID   string `json:"id,omitempty" yaml:"id,omitempty" ecs:"observer.egress.vlan.id"`
	Name string `json:"name,omitempty" yaml:"name,omitempty" ecs:"observer.egress.vlan.name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b ObserverEgressVLAN) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	return json.Marshal(res)
}

// ObserverGeo defines the object located at ECS path observer.geo.
type ObserverGeo struct {
	CityName       string           `json:"city_name,omitempty" yaml:"city_name,omitempty" ecs:"observer.geo.city_name"`
	ContinentName  string           `json:"continent_name,omitempty" yaml:"continent_name,omitempty" ecs:"observer.geo.continent_name"`
	CountryISOCode string           `json:"country_iso_code,omitempty" yaml:"country_iso_code,omitempty" ecs:"observer.geo.country_iso_code"`
	CountryName    string           `json:"country_name,omitempty" yaml:"country_name,omitempty" ecs:"observer.geo.country_name"`
	Location       ObserverGeoPoint `json:"location,omitempty" yaml:"location,omitempty" ecs:"observer.geo.location"`
	Name           string           `json:"name,omitempty" yaml:"name,omitempty" ecs:"observer.geo.name"`
	RegionISOCode  string           `json:"region_iso_code,omitempty" yaml:"region_iso_code,omitempty" ecs:"observer.geo.region_iso_code"`
	RegionName     string           `json:"region_name,omitempty" yaml:"region_name,omitempty" ecs:"observer.geo.region_name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b ObserverGeo) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.CityName); !val.IsZero() {
		res["city_name"] = b.CityName
	}

	if val := reflect.ValueOf(b.ContinentName); !val.IsZero() {
		res["continent_name"] = b.ContinentName
	}

	if val := reflect.ValueOf(b.CountryISOCode); !val.IsZero() {
		res["country_iso_code"] = b.CountryISOCode
	}

	if val := reflect.ValueOf(b.CountryName); !val.IsZero() {
		res["country_name"] = b.CountryName
	}

	if val := reflect.ValueOf(b.Location); !val.IsZero() {
		res["location"] = b.Location
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	if val := reflect.ValueOf(b.RegionISOCode); !val.IsZero() {
		res["region_iso_code"] = b.RegionISOCode
	}

	if val := reflect.ValueOf(b.RegionName); !val.IsZero() {
		res["region_name"] = b.RegionName
	}

	return json.Marshal(res)
}

// GeoPoint defines the object at ECS path observer.geo.location
type ObserverGeoPoint struct {
	Latitude  json.Number `json:"lat,omitempty" yaml:"lat,omitempty" ecs:"observer.geo.location.lat"`
	Longitude json.Number `json:"lon,omitempty" yaml:"lon,omitempty" ecs:"observer.geo.location.lon"`
}

func (b ObserverGeoPoint) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Latitude); !val.IsZero() {
		res["lat"] = b.Latitude
	}

	if val := reflect.ValueOf(b.Longitude); !val.IsZero() {
		res["lon"] = b.Longitude
	}

	return json.Marshal(res)
}

// ObserverIngress defines the object located at ECS path observer.ingress.
type ObserverIngress struct {
	Interface ObserverIngressInterface `json:"interface,omitempty" yaml:"interface,omitempty" ecs:"observer.ingress.interface"`
	VLAN      ObserverIngressVLAN      `json:"vlan,omitempty" yaml:"vlan,omitempty" ecs:"observer.ingress.vlan"`
	Zone      string                   `json:"zone,omitempty" yaml:"zone,omitempty" ecs:"observer.ingress.zone"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b ObserverIngress) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Interface); !val.IsZero() {
		res["interface"] = b.Interface
	}

	if val := reflect.ValueOf(b.VLAN); !val.IsZero() {
		res["vlan"] = b.VLAN
	}

	if val := reflect.ValueOf(b.Zone); !val.IsZero() {
		res["zone"] = b.Zone
	}

	return json.Marshal(res)
}

// ObserverIngressInterface defines the object located at ECS path observer.ingress.interface.
type ObserverIngressInterface struct {
	Alias string `json:"alias,omitempty" yaml:"alias,omitempty" ecs:"observer.ingress.interface.alias"`
	ID    string `json:"id,omitempty" yaml:"id,omitempty" ecs:"observer.ingress.interface.id"`
	Name  string `json:"name,omitempty" yaml:"name,omitempty" ecs:"observer.ingress.interface.name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b ObserverIngressInterface) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Alias); !val.IsZero() {
		res["alias"] = b.Alias
	}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	return json.Marshal(res)
}

// ObserverIngressVLAN defines the object located at ECS path observer.ingress.vlan.
type ObserverIngressVLAN struct {
	ID   string `json:"id,omitempty" yaml:"id,omitempty" ecs:"observer.ingress.vlan.id"`
	Name string `json:"name,omitempty" yaml:"name,omitempty" ecs:"observer.ingress.vlan.name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b ObserverIngressVLAN) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	return json.Marshal(res)
}

// ObserverOS defines the object located at ECS path observer.os.
type ObserverOS struct {
	Family   string `json:"family,omitempty" yaml:"family,omitempty" ecs:"observer.os.family"`
	Full     string `json:"full,omitempty" yaml:"full,omitempty" ecs:"observer.os.full"`
	Kernel   string `json:"kernel,omitempty" yaml:"kernel,omitempty" ecs:"observer.os.kernel"`
	Name     string `json:"name,omitempty" yaml:"name,omitempty" ecs:"observer.os.name"`
	Platform string `json:"platform,omitempty" yaml:"platform,omitempty" ecs:"observer.os.platform"`
	Version  string `json:"version,omitempty" yaml:"version,omitempty" ecs:"observer.os.version"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b ObserverOS) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Family); !val.IsZero() {
		res["family"] = b.Family
	}

	if val := reflect.ValueOf(b.Full); !val.IsZero() {
		res["full"] = b.Full
	}

	if val := reflect.ValueOf(b.Kernel); !val.IsZero() {
		res["kernel"] = b.Kernel
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	if val := reflect.ValueOf(b.Platform); !val.IsZero() {
		res["platform"] = b.Platform
	}

	if val := reflect.ValueOf(b.Version); !val.IsZero() {
		res["version"] = b.Version
	}

	return json.Marshal(res)
}

// Organization defines the object located at ECS path organization.
type Organization struct {
	ID   string `json:"id,omitempty" yaml:"id,omitempty" ecs:"organization.id"`
	Name string `json:"name,omitempty" yaml:"name,omitempty" ecs:"organization.name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b Organization) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	return json.Marshal(res)
}

// Package defines the object located at ECS path package.
type Package struct {
	Architecture string      `json:"architecture,omitempty" yaml:"architecture,omitempty" ecs:"package.architecture"`
	BuildVersion string      `json:"build_version,omitempty" yaml:"build_version,omitempty" ecs:"package.build_version"`
	Checksum     string      `json:"checksum,omitempty" yaml:"checksum,omitempty" ecs:"package.checksum"`
	Description  string      `json:"description,omitempty" yaml:"description,omitempty" ecs:"package.description"`
	InstallScope string      `json:"install_scope,omitempty" yaml:"install_scope,omitempty" ecs:"package.install_scope"`
	Installed    time.Time   `json:"installed,omitempty" yaml:"installed,omitempty" ecs:"package.installed"`
	License      string      `json:"license,omitempty" yaml:"license,omitempty" ecs:"package.license"`
	Name         string      `json:"name,omitempty" yaml:"name,omitempty" ecs:"package.name"`
	Path         string      `json:"path,omitempty" yaml:"path,omitempty" ecs:"package.path"`
	Reference    string      `json:"reference,omitempty" yaml:"reference,omitempty" ecs:"package.reference"`
	Size         json.Number `json:"size,omitempty" yaml:"size,omitempty" ecs:"package.size"`
	Type         string      `json:"type,omitempty" yaml:"type,omitempty" ecs:"package.type"`
	Version      string      `json:"version,omitempty" yaml:"version,omitempty" ecs:"package.version"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b Package) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Architecture); !val.IsZero() {
		res["architecture"] = b.Architecture
	}

	if val := reflect.ValueOf(b.BuildVersion); !val.IsZero() {
		res["build_version"] = b.BuildVersion
	}

	if val := reflect.ValueOf(b.Checksum); !val.IsZero() {
		res["checksum"] = b.Checksum
	}

	if val := reflect.ValueOf(b.Description); !val.IsZero() {
		res["description"] = b.Description
	}

	if val := reflect.ValueOf(b.InstallScope); !val.IsZero() {
		res["install_scope"] = b.InstallScope
	}

	if val := reflect.ValueOf(b.Installed); !val.IsZero() {
		res["installed"] = b.Installed
	}

	if val := reflect.ValueOf(b.License); !val.IsZero() {
		res["license"] = b.License
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	if val := reflect.ValueOf(b.Path); !val.IsZero() {
		res["path"] = b.Path
	}

	if val := reflect.ValueOf(b.Reference); !val.IsZero() {
		res["reference"] = b.Reference
	}

	if val := reflect.ValueOf(b.Size); !val.IsZero() {
		res["size"] = b.Size
	}

	if val := reflect.ValueOf(b.Type); !val.IsZero() {
		res["type"] = b.Type
	}

	if val := reflect.ValueOf(b.Version); !val.IsZero() {
		res["version"] = b.Version
	}

	return json.Marshal(res)
}

// Process defines the object located at ECS path process.
type Process struct {
	Args             [][]string           `json:"args,omitempty" yaml:"args,omitempty" ecs:"process.args"`
	ArgsCount        json.Number          `json:"args_count,omitempty" yaml:"args_count,omitempty" ecs:"process.args_count"`
	CodeSignature    ProcessCodeSignature `json:"code_signature,omitempty" yaml:"code_signature,omitempty" ecs:"process.code_signature"`
	CommandLine      string               `json:"command_line,omitempty" yaml:"command_line,omitempty" ecs:"process.command_line"`
	EntityID         string               `json:"entity_id,omitempty" yaml:"entity_id,omitempty" ecs:"process.entity_id"`
	Executable       string               `json:"executable,omitempty" yaml:"executable,omitempty" ecs:"process.executable"`
	ExitCode         json.Number          `json:"exit_code,omitempty" yaml:"exit_code,omitempty" ecs:"process.exit_code"`
	Hash             ProcessHash          `json:"hash,omitempty" yaml:"hash,omitempty" ecs:"process.hash"`
	Name             string               `json:"name,omitempty" yaml:"name,omitempty" ecs:"process.name"`
	Parent           ProcessParent        `json:"parent,omitempty" yaml:"parent,omitempty" ecs:"process.parent"`
	PE               ProcessPE            `json:"pe,omitempty" yaml:"pe,omitempty" ecs:"process.pe"`
	PGID             json.Number          `json:"pgid,omitempty" yaml:"pgid,omitempty" ecs:"process.pgid"`
	PID              json.Number          `json:"pid,omitempty" yaml:"pid,omitempty" ecs:"process.pid"`
	PPID             json.Number          `json:"ppid,omitempty" yaml:"ppid,omitempty" ecs:"process.ppid"`
	Start            time.Time            `json:"start,omitempty" yaml:"start,omitempty" ecs:"process.start"`
	Thread           ProcessThread        `json:"thread,omitempty" yaml:"thread,omitempty" ecs:"process.thread"`
	Title            string               `json:"title,omitempty" yaml:"title,omitempty" ecs:"process.title"`
	Uptime           json.Number          `json:"uptime,omitempty" yaml:"uptime,omitempty" ecs:"process.uptime"`
	WorkingDirectory string               `json:"working_directory,omitempty" yaml:"working_directory,omitempty" ecs:"process.working_directory"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b Process) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Args); !val.IsZero() {
		res["args"] = b.Args
	}

	if val := reflect.ValueOf(b.ArgsCount); !val.IsZero() {
		res["args_count"] = b.ArgsCount
	}

	if val := reflect.ValueOf(b.CodeSignature); !val.IsZero() {
		res["code_signature"] = b.CodeSignature
	}

	if val := reflect.ValueOf(b.CommandLine); !val.IsZero() {
		res["command_line"] = b.CommandLine
	}

	if val := reflect.ValueOf(b.EntityID); !val.IsZero() {
		res["entity_id"] = b.EntityID
	}

	if val := reflect.ValueOf(b.Executable); !val.IsZero() {
		res["executable"] = b.Executable
	}

	if val := reflect.ValueOf(b.ExitCode); !val.IsZero() {
		res["exit_code"] = b.ExitCode
	}

	if val := reflect.ValueOf(b.Hash); !val.IsZero() {
		res["hash"] = b.Hash
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	if val := reflect.ValueOf(b.Parent); !val.IsZero() {
		res["parent"] = b.Parent
	}

	if val := reflect.ValueOf(b.PE); !val.IsZero() {
		res["pe"] = b.PE
	}

	if val := reflect.ValueOf(b.PGID); !val.IsZero() {
		res["pgid"] = b.PGID
	}

	if val := reflect.ValueOf(b.PID); !val.IsZero() {
		res["pid"] = b.PID
	}

	if val := reflect.ValueOf(b.PPID); !val.IsZero() {
		res["ppid"] = b.PPID
	}

	if val := reflect.ValueOf(b.Start); !val.IsZero() {
		res["start"] = b.Start
	}

	if val := reflect.ValueOf(b.Thread); !val.IsZero() {
		res["thread"] = b.Thread
	}

	if val := reflect.ValueOf(b.Title); !val.IsZero() {
		res["title"] = b.Title
	}

	if val := reflect.ValueOf(b.Uptime); !val.IsZero() {
		res["uptime"] = b.Uptime
	}

	if val := reflect.ValueOf(b.WorkingDirectory); !val.IsZero() {
		res["working_directory"] = b.WorkingDirectory
	}

	return json.Marshal(res)
}

// ProcessCodeSignature defines the object located at ECS path process.code_signature.
type ProcessCodeSignature struct {
	Exists      bool   `json:"exists,omitempty" yaml:"exists,omitempty" ecs:"process.code_signature.exists"`
	Status      string `json:"status,omitempty" yaml:"status,omitempty" ecs:"process.code_signature.status"`
	SubjectName string `json:"subject_name,omitempty" yaml:"subject_name,omitempty" ecs:"process.code_signature.subject_name"`
	Trusted     bool   `json:"trusted,omitempty" yaml:"trusted,omitempty" ecs:"process.code_signature.trusted"`
	Valid       bool   `json:"valid,omitempty" yaml:"valid,omitempty" ecs:"process.code_signature.valid"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b ProcessCodeSignature) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Exists); !val.IsZero() {
		res["exists"] = b.Exists
	}

	if val := reflect.ValueOf(b.Status); !val.IsZero() {
		res["status"] = b.Status
	}

	if val := reflect.ValueOf(b.SubjectName); !val.IsZero() {
		res["subject_name"] = b.SubjectName
	}

	if val := reflect.ValueOf(b.Trusted); !val.IsZero() {
		res["trusted"] = b.Trusted
	}

	if val := reflect.ValueOf(b.Valid); !val.IsZero() {
		res["valid"] = b.Valid
	}

	return json.Marshal(res)
}

// ProcessHash defines the object located at ECS path process.hash.
type ProcessHash struct {
	MD5    string `json:"md5,omitempty" yaml:"md5,omitempty" ecs:"process.hash.md5"`
	SHA1   string `json:"sha1,omitempty" yaml:"sha1,omitempty" ecs:"process.hash.sha1"`
	SHA256 string `json:"sha256,omitempty" yaml:"sha256,omitempty" ecs:"process.hash.sha256"`
	SHA512 string `json:"sha512,omitempty" yaml:"sha512,omitempty" ecs:"process.hash.sha512"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b ProcessHash) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.MD5); !val.IsZero() {
		res["md5"] = b.MD5
	}

	if val := reflect.ValueOf(b.SHA1); !val.IsZero() {
		res["sha1"] = b.SHA1
	}

	if val := reflect.ValueOf(b.SHA256); !val.IsZero() {
		res["sha256"] = b.SHA256
	}

	if val := reflect.ValueOf(b.SHA512); !val.IsZero() {
		res["sha512"] = b.SHA512
	}

	return json.Marshal(res)
}

// ProcessParent defines the object located at ECS path process.parent.
type ProcessParent struct {
	Args             [][]string                 `json:"args,omitempty" yaml:"args,omitempty" ecs:"process.parent.args"`
	ArgsCount        json.Number                `json:"args_count,omitempty" yaml:"args_count,omitempty" ecs:"process.parent.args_count"`
	CodeSignature    ProcessParentCodeSignature `json:"code_signature,omitempty" yaml:"code_signature,omitempty" ecs:"process.parent.code_signature"`
	CommandLine      string                     `json:"command_line,omitempty" yaml:"command_line,omitempty" ecs:"process.parent.command_line"`
	EntityID         string                     `json:"entity_id,omitempty" yaml:"entity_id,omitempty" ecs:"process.parent.entity_id"`
	Executable       string                     `json:"executable,omitempty" yaml:"executable,omitempty" ecs:"process.parent.executable"`
	ExitCode         json.Number                `json:"exit_code,omitempty" yaml:"exit_code,omitempty" ecs:"process.parent.exit_code"`
	Hash             ProcessParentHash          `json:"hash,omitempty" yaml:"hash,omitempty" ecs:"process.parent.hash"`
	Name             string                     `json:"name,omitempty" yaml:"name,omitempty" ecs:"process.parent.name"`
	PE               ProcessParentPE            `json:"pe,omitempty" yaml:"pe,omitempty" ecs:"process.parent.pe"`
	PGID             json.Number                `json:"pgid,omitempty" yaml:"pgid,omitempty" ecs:"process.parent.pgid"`
	PID              json.Number                `json:"pid,omitempty" yaml:"pid,omitempty" ecs:"process.parent.pid"`
	PPID             json.Number                `json:"ppid,omitempty" yaml:"ppid,omitempty" ecs:"process.parent.ppid"`
	Start            time.Time                  `json:"start,omitempty" yaml:"start,omitempty" ecs:"process.parent.start"`
	Thread           ProcessParentThread        `json:"thread,omitempty" yaml:"thread,omitempty" ecs:"process.parent.thread"`
	Title            string                     `json:"title,omitempty" yaml:"title,omitempty" ecs:"process.parent.title"`
	Uptime           json.Number                `json:"uptime,omitempty" yaml:"uptime,omitempty" ecs:"process.parent.uptime"`
	WorkingDirectory string                     `json:"working_directory,omitempty" yaml:"working_directory,omitempty" ecs:"process.parent.working_directory"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b ProcessParent) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Args); !val.IsZero() {
		res["args"] = b.Args
	}

	if val := reflect.ValueOf(b.ArgsCount); !val.IsZero() {
		res["args_count"] = b.ArgsCount
	}

	if val := reflect.ValueOf(b.CodeSignature); !val.IsZero() {
		res["code_signature"] = b.CodeSignature
	}

	if val := reflect.ValueOf(b.CommandLine); !val.IsZero() {
		res["command_line"] = b.CommandLine
	}

	if val := reflect.ValueOf(b.EntityID); !val.IsZero() {
		res["entity_id"] = b.EntityID
	}

	if val := reflect.ValueOf(b.Executable); !val.IsZero() {
		res["executable"] = b.Executable
	}

	if val := reflect.ValueOf(b.ExitCode); !val.IsZero() {
		res["exit_code"] = b.ExitCode
	}

	if val := reflect.ValueOf(b.Hash); !val.IsZero() {
		res["hash"] = b.Hash
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	if val := reflect.ValueOf(b.PE); !val.IsZero() {
		res["pe"] = b.PE
	}

	if val := reflect.ValueOf(b.PGID); !val.IsZero() {
		res["pgid"] = b.PGID
	}

	if val := reflect.ValueOf(b.PID); !val.IsZero() {
		res["pid"] = b.PID
	}

	if val := reflect.ValueOf(b.PPID); !val.IsZero() {
		res["ppid"] = b.PPID
	}

	if val := reflect.ValueOf(b.Start); !val.IsZero() {
		res["start"] = b.Start
	}

	if val := reflect.ValueOf(b.Thread); !val.IsZero() {
		res["thread"] = b.Thread
	}

	if val := reflect.ValueOf(b.Title); !val.IsZero() {
		res["title"] = b.Title
	}

	if val := reflect.ValueOf(b.Uptime); !val.IsZero() {
		res["uptime"] = b.Uptime
	}

	if val := reflect.ValueOf(b.WorkingDirectory); !val.IsZero() {
		res["working_directory"] = b.WorkingDirectory
	}

	return json.Marshal(res)
}

// ProcessParentCodeSignature defines the object located at ECS path process.parent.code_signature.
type ProcessParentCodeSignature struct {
	Exists      bool   `json:"exists,omitempty" yaml:"exists,omitempty" ecs:"process.parent.code_signature.exists"`
	Status      string `json:"status,omitempty" yaml:"status,omitempty" ecs:"process.parent.code_signature.status"`
	SubjectName string `json:"subject_name,omitempty" yaml:"subject_name,omitempty" ecs:"process.parent.code_signature.subject_name"`
	Trusted     bool   `json:"trusted,omitempty" yaml:"trusted,omitempty" ecs:"process.parent.code_signature.trusted"`
	Valid       bool   `json:"valid,omitempty" yaml:"valid,omitempty" ecs:"process.parent.code_signature.valid"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b ProcessParentCodeSignature) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Exists); !val.IsZero() {
		res["exists"] = b.Exists
	}

	if val := reflect.ValueOf(b.Status); !val.IsZero() {
		res["status"] = b.Status
	}

	if val := reflect.ValueOf(b.SubjectName); !val.IsZero() {
		res["subject_name"] = b.SubjectName
	}

	if val := reflect.ValueOf(b.Trusted); !val.IsZero() {
		res["trusted"] = b.Trusted
	}

	if val := reflect.ValueOf(b.Valid); !val.IsZero() {
		res["valid"] = b.Valid
	}

	return json.Marshal(res)
}

// ProcessParentHash defines the object located at ECS path process.parent.hash.
type ProcessParentHash struct {
	MD5    string `json:"md5,omitempty" yaml:"md5,omitempty" ecs:"process.parent.hash.md5"`
	SHA1   string `json:"sha1,omitempty" yaml:"sha1,omitempty" ecs:"process.parent.hash.sha1"`
	SHA256 string `json:"sha256,omitempty" yaml:"sha256,omitempty" ecs:"process.parent.hash.sha256"`
	SHA512 string `json:"sha512,omitempty" yaml:"sha512,omitempty" ecs:"process.parent.hash.sha512"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b ProcessParentHash) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.MD5); !val.IsZero() {
		res["md5"] = b.MD5
	}

	if val := reflect.ValueOf(b.SHA1); !val.IsZero() {
		res["sha1"] = b.SHA1
	}

	if val := reflect.ValueOf(b.SHA256); !val.IsZero() {
		res["sha256"] = b.SHA256
	}

	if val := reflect.ValueOf(b.SHA512); !val.IsZero() {
		res["sha512"] = b.SHA512
	}

	return json.Marshal(res)
}

// ProcessParentPE defines the object located at ECS path process.parent.pe.
type ProcessParentPE struct {
	Architecture     string `json:"architecture,omitempty" yaml:"architecture,omitempty" ecs:"process.parent.pe.architecture"`
	Company          string `json:"company,omitempty" yaml:"company,omitempty" ecs:"process.parent.pe.company"`
	Description      string `json:"description,omitempty" yaml:"description,omitempty" ecs:"process.parent.pe.description"`
	FileVersion      string `json:"file_version,omitempty" yaml:"file_version,omitempty" ecs:"process.parent.pe.file_version"`
	Imphash          string `json:"imphash,omitempty" yaml:"imphash,omitempty" ecs:"process.parent.pe.imphash"`
	OriginalFileName string `json:"original_file_name,omitempty" yaml:"original_file_name,omitempty" ecs:"process.parent.pe.original_file_name"`
	Product          string `json:"product,omitempty" yaml:"product,omitempty" ecs:"process.parent.pe.product"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b ProcessParentPE) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Architecture); !val.IsZero() {
		res["architecture"] = b.Architecture
	}

	if val := reflect.ValueOf(b.Company); !val.IsZero() {
		res["company"] = b.Company
	}

	if val := reflect.ValueOf(b.Description); !val.IsZero() {
		res["description"] = b.Description
	}

	if val := reflect.ValueOf(b.FileVersion); !val.IsZero() {
		res["file_version"] = b.FileVersion
	}

	if val := reflect.ValueOf(b.Imphash); !val.IsZero() {
		res["imphash"] = b.Imphash
	}

	if val := reflect.ValueOf(b.OriginalFileName); !val.IsZero() {
		res["original_file_name"] = b.OriginalFileName
	}

	if val := reflect.ValueOf(b.Product); !val.IsZero() {
		res["product"] = b.Product
	}

	return json.Marshal(res)
}

// ProcessParentThread defines the object located at ECS path process.parent.thread.
type ProcessParentThread struct {
	ID   json.Number `json:"id,omitempty" yaml:"id,omitempty" ecs:"process.parent.thread.id"`
	Name string      `json:"name,omitempty" yaml:"name,omitempty" ecs:"process.parent.thread.name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b ProcessParentThread) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	return json.Marshal(res)
}

// ProcessPE defines the object located at ECS path process.pe.
type ProcessPE struct {
	Architecture     string `json:"architecture,omitempty" yaml:"architecture,omitempty" ecs:"process.pe.architecture"`
	Company          string `json:"company,omitempty" yaml:"company,omitempty" ecs:"process.pe.company"`
	Description      string `json:"description,omitempty" yaml:"description,omitempty" ecs:"process.pe.description"`
	FileVersion      string `json:"file_version,omitempty" yaml:"file_version,omitempty" ecs:"process.pe.file_version"`
	Imphash          string `json:"imphash,omitempty" yaml:"imphash,omitempty" ecs:"process.pe.imphash"`
	OriginalFileName string `json:"original_file_name,omitempty" yaml:"original_file_name,omitempty" ecs:"process.pe.original_file_name"`
	Product          string `json:"product,omitempty" yaml:"product,omitempty" ecs:"process.pe.product"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b ProcessPE) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Architecture); !val.IsZero() {
		res["architecture"] = b.Architecture
	}

	if val := reflect.ValueOf(b.Company); !val.IsZero() {
		res["company"] = b.Company
	}

	if val := reflect.ValueOf(b.Description); !val.IsZero() {
		res["description"] = b.Description
	}

	if val := reflect.ValueOf(b.FileVersion); !val.IsZero() {
		res["file_version"] = b.FileVersion
	}

	if val := reflect.ValueOf(b.Imphash); !val.IsZero() {
		res["imphash"] = b.Imphash
	}

	if val := reflect.ValueOf(b.OriginalFileName); !val.IsZero() {
		res["original_file_name"] = b.OriginalFileName
	}

	if val := reflect.ValueOf(b.Product); !val.IsZero() {
		res["product"] = b.Product
	}

	return json.Marshal(res)
}

// ProcessThread defines the object located at ECS path process.thread.
type ProcessThread struct {
	ID   json.Number `json:"id,omitempty" yaml:"id,omitempty" ecs:"process.thread.id"`
	Name string      `json:"name,omitempty" yaml:"name,omitempty" ecs:"process.thread.name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b ProcessThread) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	return json.Marshal(res)
}

// Registry defines the object located at ECS path registry.
type Registry struct {
	Data  RegistryData `json:"data,omitempty" yaml:"data,omitempty" ecs:"registry.data"`
	Hive  string       `json:"hive,omitempty" yaml:"hive,omitempty" ecs:"registry.hive"`
	Key   string       `json:"key,omitempty" yaml:"key,omitempty" ecs:"registry.key"`
	Path  string       `json:"path,omitempty" yaml:"path,omitempty" ecs:"registry.path"`
	Value string       `json:"value,omitempty" yaml:"value,omitempty" ecs:"registry.value"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b Registry) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Data); !val.IsZero() {
		res["data"] = b.Data
	}

	if val := reflect.ValueOf(b.Hive); !val.IsZero() {
		res["hive"] = b.Hive
	}

	if val := reflect.ValueOf(b.Key); !val.IsZero() {
		res["key"] = b.Key
	}

	if val := reflect.ValueOf(b.Path); !val.IsZero() {
		res["path"] = b.Path
	}

	if val := reflect.ValueOf(b.Value); !val.IsZero() {
		res["value"] = b.Value
	}

	return json.Marshal(res)
}

// RegistryData defines the object located at ECS path registry.data.
type RegistryData struct {
	Bytes   string   `json:"bytes,omitempty" yaml:"bytes,omitempty" ecs:"registry.data.bytes"`
	Strings []string `json:"strings,omitempty" yaml:"strings,omitempty" ecs:"registry.data.strings"`
	Type    string   `json:"type,omitempty" yaml:"type,omitempty" ecs:"registry.data.type"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b RegistryData) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Bytes); !val.IsZero() {
		res["bytes"] = b.Bytes
	}

	if val := reflect.ValueOf(b.Strings); !val.IsZero() {
		res["strings"] = b.Strings
	}

	if val := reflect.ValueOf(b.Type); !val.IsZero() {
		res["type"] = b.Type
	}

	return json.Marshal(res)
}

// Related defines the object located at ECS path related.
type Related struct {
	Hash  []string `json:"hash,omitempty" yaml:"hash,omitempty" ecs:"related.hash"`
	Hosts []string `json:"hosts,omitempty" yaml:"hosts,omitempty" ecs:"related.hosts"`
	IP    []string `json:"ip,omitempty" yaml:"ip,omitempty" ecs:"related.ip"`
	User  []string `json:"user,omitempty" yaml:"user,omitempty" ecs:"related.user"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b Related) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Hash); !val.IsZero() {
		res["hash"] = b.Hash
	}

	if val := reflect.ValueOf(b.Hosts); !val.IsZero() {
		res["hosts"] = b.Hosts
	}

	if val := reflect.ValueOf(b.IP); !val.IsZero() {
		res["ip"] = b.IP
	}

	if val := reflect.ValueOf(b.User); !val.IsZero() {
		res["user"] = b.User
	}

	return json.Marshal(res)
}

// Rule defines the object located at ECS path rule.
type Rule struct {
	Author      []string `json:"author,omitempty" yaml:"author,omitempty" ecs:"rule.author"`
	Category    string   `json:"category,omitempty" yaml:"category,omitempty" ecs:"rule.category"`
	Description string   `json:"description,omitempty" yaml:"description,omitempty" ecs:"rule.description"`
	ID          string   `json:"id,omitempty" yaml:"id,omitempty" ecs:"rule.id"`
	License     string   `json:"license,omitempty" yaml:"license,omitempty" ecs:"rule.license"`
	Name        string   `json:"name,omitempty" yaml:"name,omitempty" ecs:"rule.name"`
	Reference   string   `json:"reference,omitempty" yaml:"reference,omitempty" ecs:"rule.reference"`
	Ruleset     string   `json:"ruleset,omitempty" yaml:"ruleset,omitempty" ecs:"rule.ruleset"`
	UUID        string   `json:"uuid,omitempty" yaml:"uuid,omitempty" ecs:"rule.uuid"`
	Version     string   `json:"version,omitempty" yaml:"version,omitempty" ecs:"rule.version"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b Rule) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Author); !val.IsZero() {
		res["author"] = b.Author
	}

	if val := reflect.ValueOf(b.Category); !val.IsZero() {
		res["category"] = b.Category
	}

	if val := reflect.ValueOf(b.Description); !val.IsZero() {
		res["description"] = b.Description
	}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.License); !val.IsZero() {
		res["license"] = b.License
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	if val := reflect.ValueOf(b.Reference); !val.IsZero() {
		res["reference"] = b.Reference
	}

	if val := reflect.ValueOf(b.Ruleset); !val.IsZero() {
		res["ruleset"] = b.Ruleset
	}

	if val := reflect.ValueOf(b.UUID); !val.IsZero() {
		res["uuid"] = b.UUID
	}

	if val := reflect.ValueOf(b.Version); !val.IsZero() {
		res["version"] = b.Version
	}

	return json.Marshal(res)
}

// Server defines the object located at ECS path server.
type Server struct {
	Address          string      `json:"address,omitempty" yaml:"address,omitempty" ecs:"server.address"`
	AS               ServerAS    `json:"as,omitempty" yaml:"as,omitempty" ecs:"server.as"`
	Bytes            json.Number `json:"bytes,omitempty" yaml:"bytes,omitempty" ecs:"server.bytes"`
	Domain           string      `json:"domain,omitempty" yaml:"domain,omitempty" ecs:"server.domain"`
	Geo              ServerGeo   `json:"geo,omitempty" yaml:"geo,omitempty" ecs:"server.geo"`
	IP               string      `json:"ip,omitempty" yaml:"ip,omitempty" ecs:"server.ip"`
	MAC              string      `json:"mac,omitempty" yaml:"mac,omitempty" ecs:"server.mac"`
	NAT              ServerNAT   `json:"nat,omitempty" yaml:"nat,omitempty" ecs:"server.nat"`
	Packets          json.Number `json:"packets,omitempty" yaml:"packets,omitempty" ecs:"server.packets"`
	Port             json.Number `json:"port,omitempty" yaml:"port,omitempty" ecs:"server.port"`
	RegisteredDomain string      `json:"registered_domain,omitempty" yaml:"registered_domain,omitempty" ecs:"server.registered_domain"`
	TopLevelDomain   string      `json:"top_level_domain,omitempty" yaml:"top_level_domain,omitempty" ecs:"server.top_level_domain"`
	User             ServerUser  `json:"user,omitempty" yaml:"user,omitempty" ecs:"server.user"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b Server) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Address); !val.IsZero() {
		res["address"] = b.Address
	}

	if val := reflect.ValueOf(b.AS); !val.IsZero() {
		res["as"] = b.AS
	}

	if val := reflect.ValueOf(b.Bytes); !val.IsZero() {
		res["bytes"] = b.Bytes
	}

	if val := reflect.ValueOf(b.Domain); !val.IsZero() {
		res["domain"] = b.Domain
	}

	if val := reflect.ValueOf(b.Geo); !val.IsZero() {
		res["geo"] = b.Geo
	}

	if val := reflect.ValueOf(b.IP); !val.IsZero() {
		res["ip"] = b.IP
	}

	if val := reflect.ValueOf(b.MAC); !val.IsZero() {
		res["mac"] = b.MAC
	}

	if val := reflect.ValueOf(b.NAT); !val.IsZero() {
		res["nat"] = b.NAT
	}

	if val := reflect.ValueOf(b.Packets); !val.IsZero() {
		res["packets"] = b.Packets
	}

	if val := reflect.ValueOf(b.Port); !val.IsZero() {
		res["port"] = b.Port
	}

	if val := reflect.ValueOf(b.RegisteredDomain); !val.IsZero() {
		res["registered_domain"] = b.RegisteredDomain
	}

	if val := reflect.ValueOf(b.TopLevelDomain); !val.IsZero() {
		res["top_level_domain"] = b.TopLevelDomain
	}

	if val := reflect.ValueOf(b.User); !val.IsZero() {
		res["user"] = b.User
	}

	return json.Marshal(res)
}

// ServerAS defines the object located at ECS path server.as.
type ServerAS struct {
	Number       json.Number          `json:"number,omitempty" yaml:"number,omitempty" ecs:"server.as.number"`
	Organization ServerASOrganization `json:"organization,omitempty" yaml:"organization,omitempty" ecs:"server.as.organization"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b ServerAS) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Number); !val.IsZero() {
		res["number"] = b.Number
	}

	if val := reflect.ValueOf(b.Organization); !val.IsZero() {
		res["organization"] = b.Organization
	}

	return json.Marshal(res)
}

// ServerASOrganization defines the object located at ECS path server.as.organization.
type ServerASOrganization struct {
	Name string `json:"name,omitempty" yaml:"name,omitempty" ecs:"server.as.organization.name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b ServerASOrganization) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	return json.Marshal(res)
}

// ServerGeo defines the object located at ECS path server.geo.
type ServerGeo struct {
	CityName       string         `json:"city_name,omitempty" yaml:"city_name,omitempty" ecs:"server.geo.city_name"`
	ContinentName  string         `json:"continent_name,omitempty" yaml:"continent_name,omitempty" ecs:"server.geo.continent_name"`
	CountryISOCode string         `json:"country_iso_code,omitempty" yaml:"country_iso_code,omitempty" ecs:"server.geo.country_iso_code"`
	CountryName    string         `json:"country_name,omitempty" yaml:"country_name,omitempty" ecs:"server.geo.country_name"`
	Location       ServerGeoPoint `json:"location,omitempty" yaml:"location,omitempty" ecs:"server.geo.location"`
	Name           string         `json:"name,omitempty" yaml:"name,omitempty" ecs:"server.geo.name"`
	RegionISOCode  string         `json:"region_iso_code,omitempty" yaml:"region_iso_code,omitempty" ecs:"server.geo.region_iso_code"`
	RegionName     string         `json:"region_name,omitempty" yaml:"region_name,omitempty" ecs:"server.geo.region_name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b ServerGeo) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.CityName); !val.IsZero() {
		res["city_name"] = b.CityName
	}

	if val := reflect.ValueOf(b.ContinentName); !val.IsZero() {
		res["continent_name"] = b.ContinentName
	}

	if val := reflect.ValueOf(b.CountryISOCode); !val.IsZero() {
		res["country_iso_code"] = b.CountryISOCode
	}

	if val := reflect.ValueOf(b.CountryName); !val.IsZero() {
		res["country_name"] = b.CountryName
	}

	if val := reflect.ValueOf(b.Location); !val.IsZero() {
		res["location"] = b.Location
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	if val := reflect.ValueOf(b.RegionISOCode); !val.IsZero() {
		res["region_iso_code"] = b.RegionISOCode
	}

	if val := reflect.ValueOf(b.RegionName); !val.IsZero() {
		res["region_name"] = b.RegionName
	}

	return json.Marshal(res)
}

// GeoPoint defines the object at ECS path server.geo.location
type ServerGeoPoint struct {
	Latitude  json.Number `json:"lat,omitempty" yaml:"lat,omitempty" ecs:"server.geo.location.lat"`
	Longitude json.Number `json:"lon,omitempty" yaml:"lon,omitempty" ecs:"server.geo.location.lon"`
}

func (b ServerGeoPoint) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Latitude); !val.IsZero() {
		res["lat"] = b.Latitude
	}

	if val := reflect.ValueOf(b.Longitude); !val.IsZero() {
		res["lon"] = b.Longitude
	}

	return json.Marshal(res)
}

// ServerNAT defines the object located at ECS path server.nat.
type ServerNAT struct {
	IP   string      `json:"ip,omitempty" yaml:"ip,omitempty" ecs:"server.nat.ip"`
	Port json.Number `json:"port,omitempty" yaml:"port,omitempty" ecs:"server.nat.port"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b ServerNAT) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.IP); !val.IsZero() {
		res["ip"] = b.IP
	}

	if val := reflect.ValueOf(b.Port); !val.IsZero() {
		res["port"] = b.Port
	}

	return json.Marshal(res)
}

// ServerUser defines the object located at ECS path server.user.
type ServerUser struct {
	Domain   string          `json:"domain,omitempty" yaml:"domain,omitempty" ecs:"server.user.domain"`
	Email    string          `json:"email,omitempty" yaml:"email,omitempty" ecs:"server.user.email"`
	FullName string          `json:"full_name,omitempty" yaml:"full_name,omitempty" ecs:"server.user.full_name"`
	Group    ServerUserGroup `json:"group,omitempty" yaml:"group,omitempty" ecs:"server.user.group"`
	Hash     string          `json:"hash,omitempty" yaml:"hash,omitempty" ecs:"server.user.hash"`
	ID       string          `json:"id,omitempty" yaml:"id,omitempty" ecs:"server.user.id"`
	Name     string          `json:"name,omitempty" yaml:"name,omitempty" ecs:"server.user.name"`
	Roles    []string        `json:"roles,omitempty" yaml:"roles,omitempty" ecs:"server.user.roles"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b ServerUser) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Domain); !val.IsZero() {
		res["domain"] = b.Domain
	}

	if val := reflect.ValueOf(b.Email); !val.IsZero() {
		res["email"] = b.Email
	}

	if val := reflect.ValueOf(b.FullName); !val.IsZero() {
		res["full_name"] = b.FullName
	}

	if val := reflect.ValueOf(b.Group); !val.IsZero() {
		res["group"] = b.Group
	}

	if val := reflect.ValueOf(b.Hash); !val.IsZero() {
		res["hash"] = b.Hash
	}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	if val := reflect.ValueOf(b.Roles); !val.IsZero() {
		res["roles"] = b.Roles
	}

	return json.Marshal(res)
}

// ServerUserGroup defines the object located at ECS path server.user.group.
type ServerUserGroup struct {
	Domain string `json:"domain,omitempty" yaml:"domain,omitempty" ecs:"server.user.group.domain"`
	ID     string `json:"id,omitempty" yaml:"id,omitempty" ecs:"server.user.group.id"`
	Name   string `json:"name,omitempty" yaml:"name,omitempty" ecs:"server.user.group.name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b ServerUserGroup) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Domain); !val.IsZero() {
		res["domain"] = b.Domain
	}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	return json.Marshal(res)
}

// Service defines the object located at ECS path service.
type Service struct {
	EphemeralID string      `json:"ephemeral_id,omitempty" yaml:"ephemeral_id,omitempty" ecs:"service.ephemeral_id"`
	ID          string      `json:"id,omitempty" yaml:"id,omitempty" ecs:"service.id"`
	Name        string      `json:"name,omitempty" yaml:"name,omitempty" ecs:"service.name"`
	Node        ServiceNode `json:"node,omitempty" yaml:"node,omitempty" ecs:"service.node"`
	State       string      `json:"state,omitempty" yaml:"state,omitempty" ecs:"service.state"`
	Type        string      `json:"type,omitempty" yaml:"type,omitempty" ecs:"service.type"`
	Version     string      `json:"version,omitempty" yaml:"version,omitempty" ecs:"service.version"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b Service) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.EphemeralID); !val.IsZero() {
		res["ephemeral_id"] = b.EphemeralID
	}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	if val := reflect.ValueOf(b.Node); !val.IsZero() {
		res["node"] = b.Node
	}

	if val := reflect.ValueOf(b.State); !val.IsZero() {
		res["state"] = b.State
	}

	if val := reflect.ValueOf(b.Type); !val.IsZero() {
		res["type"] = b.Type
	}

	if val := reflect.ValueOf(b.Version); !val.IsZero() {
		res["version"] = b.Version
	}

	return json.Marshal(res)
}

// ServiceNode defines the object located at ECS path service.node.
type ServiceNode struct {
	Name string `json:"name,omitempty" yaml:"name,omitempty" ecs:"service.node.name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b ServiceNode) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	return json.Marshal(res)
}

// Source defines the object located at ECS path source.
type Source struct {
	Address          string      `json:"address,omitempty" yaml:"address,omitempty" ecs:"source.address"`
	AS               SourceAS    `json:"as,omitempty" yaml:"as,omitempty" ecs:"source.as"`
	Bytes            json.Number `json:"bytes,omitempty" yaml:"bytes,omitempty" ecs:"source.bytes"`
	Domain           string      `json:"domain,omitempty" yaml:"domain,omitempty" ecs:"source.domain"`
	Geo              SourceGeo   `json:"geo,omitempty" yaml:"geo,omitempty" ecs:"source.geo"`
	IP               string      `json:"ip,omitempty" yaml:"ip,omitempty" ecs:"source.ip"`
	MAC              string      `json:"mac,omitempty" yaml:"mac,omitempty" ecs:"source.mac"`
	NAT              SourceNAT   `json:"nat,omitempty" yaml:"nat,omitempty" ecs:"source.nat"`
	Packets          json.Number `json:"packets,omitempty" yaml:"packets,omitempty" ecs:"source.packets"`
	Port             json.Number `json:"port,omitempty" yaml:"port,omitempty" ecs:"source.port"`
	RegisteredDomain string      `json:"registered_domain,omitempty" yaml:"registered_domain,omitempty" ecs:"source.registered_domain"`
	TopLevelDomain   string      `json:"top_level_domain,omitempty" yaml:"top_level_domain,omitempty" ecs:"source.top_level_domain"`
	User             SourceUser  `json:"user,omitempty" yaml:"user,omitempty" ecs:"source.user"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b Source) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Address); !val.IsZero() {
		res["address"] = b.Address
	}

	if val := reflect.ValueOf(b.AS); !val.IsZero() {
		res["as"] = b.AS
	}

	if val := reflect.ValueOf(b.Bytes); !val.IsZero() {
		res["bytes"] = b.Bytes
	}

	if val := reflect.ValueOf(b.Domain); !val.IsZero() {
		res["domain"] = b.Domain
	}

	if val := reflect.ValueOf(b.Geo); !val.IsZero() {
		res["geo"] = b.Geo
	}

	if val := reflect.ValueOf(b.IP); !val.IsZero() {
		res["ip"] = b.IP
	}

	if val := reflect.ValueOf(b.MAC); !val.IsZero() {
		res["mac"] = b.MAC
	}

	if val := reflect.ValueOf(b.NAT); !val.IsZero() {
		res["nat"] = b.NAT
	}

	if val := reflect.ValueOf(b.Packets); !val.IsZero() {
		res["packets"] = b.Packets
	}

	if val := reflect.ValueOf(b.Port); !val.IsZero() {
		res["port"] = b.Port
	}

	if val := reflect.ValueOf(b.RegisteredDomain); !val.IsZero() {
		res["registered_domain"] = b.RegisteredDomain
	}

	if val := reflect.ValueOf(b.TopLevelDomain); !val.IsZero() {
		res["top_level_domain"] = b.TopLevelDomain
	}

	if val := reflect.ValueOf(b.User); !val.IsZero() {
		res["user"] = b.User
	}

	return json.Marshal(res)
}

// SourceAS defines the object located at ECS path source.as.
type SourceAS struct {
	Number       json.Number          `json:"number,omitempty" yaml:"number,omitempty" ecs:"source.as.number"`
	Organization SourceASOrganization `json:"organization,omitempty" yaml:"organization,omitempty" ecs:"source.as.organization"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b SourceAS) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Number); !val.IsZero() {
		res["number"] = b.Number
	}

	if val := reflect.ValueOf(b.Organization); !val.IsZero() {
		res["organization"] = b.Organization
	}

	return json.Marshal(res)
}

// SourceASOrganization defines the object located at ECS path source.as.organization.
type SourceASOrganization struct {
	Name string `json:"name,omitempty" yaml:"name,omitempty" ecs:"source.as.organization.name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b SourceASOrganization) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	return json.Marshal(res)
}

// SourceGeo defines the object located at ECS path source.geo.
type SourceGeo struct {
	CityName       string         `json:"city_name,omitempty" yaml:"city_name,omitempty" ecs:"source.geo.city_name"`
	ContinentName  string         `json:"continent_name,omitempty" yaml:"continent_name,omitempty" ecs:"source.geo.continent_name"`
	CountryISOCode string         `json:"country_iso_code,omitempty" yaml:"country_iso_code,omitempty" ecs:"source.geo.country_iso_code"`
	CountryName    string         `json:"country_name,omitempty" yaml:"country_name,omitempty" ecs:"source.geo.country_name"`
	Location       SourceGeoPoint `json:"location,omitempty" yaml:"location,omitempty" ecs:"source.geo.location"`
	Name           string         `json:"name,omitempty" yaml:"name,omitempty" ecs:"source.geo.name"`
	RegionISOCode  string         `json:"region_iso_code,omitempty" yaml:"region_iso_code,omitempty" ecs:"source.geo.region_iso_code"`
	RegionName     string         `json:"region_name,omitempty" yaml:"region_name,omitempty" ecs:"source.geo.region_name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b SourceGeo) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.CityName); !val.IsZero() {
		res["city_name"] = b.CityName
	}

	if val := reflect.ValueOf(b.ContinentName); !val.IsZero() {
		res["continent_name"] = b.ContinentName
	}

	if val := reflect.ValueOf(b.CountryISOCode); !val.IsZero() {
		res["country_iso_code"] = b.CountryISOCode
	}

	if val := reflect.ValueOf(b.CountryName); !val.IsZero() {
		res["country_name"] = b.CountryName
	}

	if val := reflect.ValueOf(b.Location); !val.IsZero() {
		res["location"] = b.Location
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	if val := reflect.ValueOf(b.RegionISOCode); !val.IsZero() {
		res["region_iso_code"] = b.RegionISOCode
	}

	if val := reflect.ValueOf(b.RegionName); !val.IsZero() {
		res["region_name"] = b.RegionName
	}

	return json.Marshal(res)
}

// GeoPoint defines the object at ECS path source.geo.location
type SourceGeoPoint struct {
	Latitude  json.Number `json:"lat,omitempty" yaml:"lat,omitempty" ecs:"source.geo.location.lat"`
	Longitude json.Number `json:"lon,omitempty" yaml:"lon,omitempty" ecs:"source.geo.location.lon"`
}

func (b SourceGeoPoint) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Latitude); !val.IsZero() {
		res["lat"] = b.Latitude
	}

	if val := reflect.ValueOf(b.Longitude); !val.IsZero() {
		res["lon"] = b.Longitude
	}

	return json.Marshal(res)
}

// SourceNAT defines the object located at ECS path source.nat.
type SourceNAT struct {
	IP   string      `json:"ip,omitempty" yaml:"ip,omitempty" ecs:"source.nat.ip"`
	Port json.Number `json:"port,omitempty" yaml:"port,omitempty" ecs:"source.nat.port"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b SourceNAT) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.IP); !val.IsZero() {
		res["ip"] = b.IP
	}

	if val := reflect.ValueOf(b.Port); !val.IsZero() {
		res["port"] = b.Port
	}

	return json.Marshal(res)
}

// SourceUser defines the object located at ECS path source.user.
type SourceUser struct {
	Domain   string          `json:"domain,omitempty" yaml:"domain,omitempty" ecs:"source.user.domain"`
	Email    string          `json:"email,omitempty" yaml:"email,omitempty" ecs:"source.user.email"`
	FullName string          `json:"full_name,omitempty" yaml:"full_name,omitempty" ecs:"source.user.full_name"`
	Group    SourceUserGroup `json:"group,omitempty" yaml:"group,omitempty" ecs:"source.user.group"`
	Hash     string          `json:"hash,omitempty" yaml:"hash,omitempty" ecs:"source.user.hash"`
	ID       string          `json:"id,omitempty" yaml:"id,omitempty" ecs:"source.user.id"`
	Name     string          `json:"name,omitempty" yaml:"name,omitempty" ecs:"source.user.name"`
	Roles    []string        `json:"roles,omitempty" yaml:"roles,omitempty" ecs:"source.user.roles"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b SourceUser) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Domain); !val.IsZero() {
		res["domain"] = b.Domain
	}

	if val := reflect.ValueOf(b.Email); !val.IsZero() {
		res["email"] = b.Email
	}

	if val := reflect.ValueOf(b.FullName); !val.IsZero() {
		res["full_name"] = b.FullName
	}

	if val := reflect.ValueOf(b.Group); !val.IsZero() {
		res["group"] = b.Group
	}

	if val := reflect.ValueOf(b.Hash); !val.IsZero() {
		res["hash"] = b.Hash
	}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	if val := reflect.ValueOf(b.Roles); !val.IsZero() {
		res["roles"] = b.Roles
	}

	return json.Marshal(res)
}

// SourceUserGroup defines the object located at ECS path source.user.group.
type SourceUserGroup struct {
	Domain string `json:"domain,omitempty" yaml:"domain,omitempty" ecs:"source.user.group.domain"`
	ID     string `json:"id,omitempty" yaml:"id,omitempty" ecs:"source.user.group.id"`
	Name   string `json:"name,omitempty" yaml:"name,omitempty" ecs:"source.user.group.name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b SourceUserGroup) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Domain); !val.IsZero() {
		res["domain"] = b.Domain
	}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	return json.Marshal(res)
}

// Span defines the object located at ECS path span.
type Span struct {
	ID string `json:"id,omitempty" yaml:"id,omitempty" ecs:"span.id"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b Span) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	return json.Marshal(res)
}

// Threat defines the object located at ECS path threat.
type Threat struct {
	Framework string          `json:"framework,omitempty" yaml:"framework,omitempty" ecs:"threat.framework"`
	Tactic    ThreatTactic    `json:"tactic,omitempty" yaml:"tactic,omitempty" ecs:"threat.tactic"`
	Technique ThreatTechnique `json:"technique,omitempty" yaml:"technique,omitempty" ecs:"threat.technique"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b Threat) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Framework); !val.IsZero() {
		res["framework"] = b.Framework
	}

	if val := reflect.ValueOf(b.Tactic); !val.IsZero() {
		res["tactic"] = b.Tactic
	}

	if val := reflect.ValueOf(b.Technique); !val.IsZero() {
		res["technique"] = b.Technique
	}

	return json.Marshal(res)
}

// ThreatTactic defines the object located at ECS path threat.tactic.
type ThreatTactic struct {
	ID        []string `json:"id,omitempty" yaml:"id,omitempty" ecs:"threat.tactic.id"`
	Name      []string `json:"name,omitempty" yaml:"name,omitempty" ecs:"threat.tactic.name"`
	Reference []string `json:"reference,omitempty" yaml:"reference,omitempty" ecs:"threat.tactic.reference"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b ThreatTactic) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	if val := reflect.ValueOf(b.Reference); !val.IsZero() {
		res["reference"] = b.Reference
	}

	return json.Marshal(res)
}

// ThreatTechnique defines the object located at ECS path threat.technique.
type ThreatTechnique struct {
	ID        []string `json:"id,omitempty" yaml:"id,omitempty" ecs:"threat.technique.id"`
	Name      []string `json:"name,omitempty" yaml:"name,omitempty" ecs:"threat.technique.name"`
	Reference []string `json:"reference,omitempty" yaml:"reference,omitempty" ecs:"threat.technique.reference"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b ThreatTechnique) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	if val := reflect.ValueOf(b.Reference); !val.IsZero() {
		res["reference"] = b.Reference
	}

	return json.Marshal(res)
}

// TLS defines the object located at ECS path tls.
type TLS struct {
	Cipher          string    `json:"cipher,omitempty" yaml:"cipher,omitempty" ecs:"tls.cipher"`
	Client          TLSClient `json:"client,omitempty" yaml:"client,omitempty" ecs:"tls.client"`
	Curve           string    `json:"curve,omitempty" yaml:"curve,omitempty" ecs:"tls.curve"`
	Established     bool      `json:"established,omitempty" yaml:"established,omitempty" ecs:"tls.established"`
	NextProtocol    string    `json:"next_protocol,omitempty" yaml:"next_protocol,omitempty" ecs:"tls.next_protocol"`
	Resumed         bool      `json:"resumed,omitempty" yaml:"resumed,omitempty" ecs:"tls.resumed"`
	Server          TLSServer `json:"server,omitempty" yaml:"server,omitempty" ecs:"tls.server"`
	Version         string    `json:"version,omitempty" yaml:"version,omitempty" ecs:"tls.version"`
	VersionProtocol string    `json:"version_protocol,omitempty" yaml:"version_protocol,omitempty" ecs:"tls.version_protocol"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b TLS) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Cipher); !val.IsZero() {
		res["cipher"] = b.Cipher
	}

	if val := reflect.ValueOf(b.Client); !val.IsZero() {
		res["client"] = b.Client
	}

	if val := reflect.ValueOf(b.Curve); !val.IsZero() {
		res["curve"] = b.Curve
	}

	if val := reflect.ValueOf(b.Established); !val.IsZero() {
		res["established"] = b.Established
	}

	if val := reflect.ValueOf(b.NextProtocol); !val.IsZero() {
		res["next_protocol"] = b.NextProtocol
	}

	if val := reflect.ValueOf(b.Resumed); !val.IsZero() {
		res["resumed"] = b.Resumed
	}

	if val := reflect.ValueOf(b.Server); !val.IsZero() {
		res["server"] = b.Server
	}

	if val := reflect.ValueOf(b.Version); !val.IsZero() {
		res["version"] = b.Version
	}

	if val := reflect.ValueOf(b.VersionProtocol); !val.IsZero() {
		res["version_protocol"] = b.VersionProtocol
	}

	return json.Marshal(res)
}

// TLSClient defines the object located at ECS path tls.client.
type TLSClient struct {
	Certificate      string        `json:"certificate,omitempty" yaml:"certificate,omitempty" ecs:"tls.client.certificate"`
	CertificateChain []string      `json:"certificate_chain,omitempty" yaml:"certificate_chain,omitempty" ecs:"tls.client.certificate_chain"`
	Hash             TLSClientHash `json:"hash,omitempty" yaml:"hash,omitempty" ecs:"tls.client.hash"`
	Issuer           string        `json:"issuer,omitempty" yaml:"issuer,omitempty" ecs:"tls.client.issuer"`
	JA3              string        `json:"ja3,omitempty" yaml:"ja3,omitempty" ecs:"tls.client.ja3"`
	NotAfter         time.Time     `json:"not_after,omitempty" yaml:"not_after,omitempty" ecs:"tls.client.not_after"`
	NotBefore        time.Time     `json:"not_before,omitempty" yaml:"not_before,omitempty" ecs:"tls.client.not_before"`
	ServerName       string        `json:"server_name,omitempty" yaml:"server_name,omitempty" ecs:"tls.client.server_name"`
	Subject          string        `json:"subject,omitempty" yaml:"subject,omitempty" ecs:"tls.client.subject"`
	SupportedCiphers []string      `json:"supported_ciphers,omitempty" yaml:"supported_ciphers,omitempty" ecs:"tls.client.supported_ciphers"`
	X509             TLSClientX509 `json:"x509,omitempty" yaml:"x509,omitempty" ecs:"tls.client.x509"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b TLSClient) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Certificate); !val.IsZero() {
		res["certificate"] = b.Certificate
	}

	if val := reflect.ValueOf(b.CertificateChain); !val.IsZero() {
		res["certificate_chain"] = b.CertificateChain
	}

	if val := reflect.ValueOf(b.Hash); !val.IsZero() {
		res["hash"] = b.Hash
	}

	if val := reflect.ValueOf(b.Issuer); !val.IsZero() {
		res["issuer"] = b.Issuer
	}

	if val := reflect.ValueOf(b.JA3); !val.IsZero() {
		res["ja3"] = b.JA3
	}

	if val := reflect.ValueOf(b.NotAfter); !val.IsZero() {
		res["not_after"] = b.NotAfter
	}

	if val := reflect.ValueOf(b.NotBefore); !val.IsZero() {
		res["not_before"] = b.NotBefore
	}

	if val := reflect.ValueOf(b.ServerName); !val.IsZero() {
		res["server_name"] = b.ServerName
	}

	if val := reflect.ValueOf(b.Subject); !val.IsZero() {
		res["subject"] = b.Subject
	}

	if val := reflect.ValueOf(b.SupportedCiphers); !val.IsZero() {
		res["supported_ciphers"] = b.SupportedCiphers
	}

	if val := reflect.ValueOf(b.X509); !val.IsZero() {
		res["x509"] = b.X509
	}

	return json.Marshal(res)
}

// TLSClientHash defines the object located at ECS path tls.client.hash.
type TLSClientHash struct {
	MD5    string `json:"md5,omitempty" yaml:"md5,omitempty" ecs:"tls.client.hash.md5"`
	SHA1   string `json:"sha1,omitempty" yaml:"sha1,omitempty" ecs:"tls.client.hash.sha1"`
	SHA256 string `json:"sha256,omitempty" yaml:"sha256,omitempty" ecs:"tls.client.hash.sha256"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b TLSClientHash) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.MD5); !val.IsZero() {
		res["md5"] = b.MD5
	}

	if val := reflect.ValueOf(b.SHA1); !val.IsZero() {
		res["sha1"] = b.SHA1
	}

	if val := reflect.ValueOf(b.SHA256); !val.IsZero() {
		res["sha256"] = b.SHA256
	}

	return json.Marshal(res)
}

// TLSClientX509 defines the object located at ECS path tls.client.x509.
type TLSClientX509 struct {
	AlternativeNames   []string             `json:"alternative_names,omitempty" yaml:"alternative_names,omitempty" ecs:"tls.client.x509.alternative_names"`
	Issuer             TLSClientX509Issuer  `json:"issuer,omitempty" yaml:"issuer,omitempty" ecs:"tls.client.x509.issuer"`
	NotAfter           time.Time            `json:"not_after,omitempty" yaml:"not_after,omitempty" ecs:"tls.client.x509.not_after"`
	NotBefore          time.Time            `json:"not_before,omitempty" yaml:"not_before,omitempty" ecs:"tls.client.x509.not_before"`
	PublicKeyAlgorithm string               `json:"public_key_algorithm,omitempty" yaml:"public_key_algorithm,omitempty" ecs:"tls.client.x509.public_key_algorithm"`
	PublicKeyCurve     string               `json:"public_key_curve,omitempty" yaml:"public_key_curve,omitempty" ecs:"tls.client.x509.public_key_curve"`
	PublicKeyExponent  json.Number          `json:"public_key_exponent,omitempty" yaml:"public_key_exponent,omitempty" ecs:"tls.client.x509.public_key_exponent"`
	PublicKeySize      json.Number          `json:"public_key_size,omitempty" yaml:"public_key_size,omitempty" ecs:"tls.client.x509.public_key_size"`
	SerialNumber       string               `json:"serial_number,omitempty" yaml:"serial_number,omitempty" ecs:"tls.client.x509.serial_number"`
	SignatureAlgorithm string               `json:"signature_algorithm,omitempty" yaml:"signature_algorithm,omitempty" ecs:"tls.client.x509.signature_algorithm"`
	Subject            TLSClientX509Subject `json:"subject,omitempty" yaml:"subject,omitempty" ecs:"tls.client.x509.subject"`
	VersionNumber      string               `json:"version_number,omitempty" yaml:"version_number,omitempty" ecs:"tls.client.x509.version_number"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b TLSClientX509) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.AlternativeNames); !val.IsZero() {
		res["alternative_names"] = b.AlternativeNames
	}

	if val := reflect.ValueOf(b.Issuer); !val.IsZero() {
		res["issuer"] = b.Issuer
	}

	if val := reflect.ValueOf(b.NotAfter); !val.IsZero() {
		res["not_after"] = b.NotAfter
	}

	if val := reflect.ValueOf(b.NotBefore); !val.IsZero() {
		res["not_before"] = b.NotBefore
	}

	if val := reflect.ValueOf(b.PublicKeyAlgorithm); !val.IsZero() {
		res["public_key_algorithm"] = b.PublicKeyAlgorithm
	}

	if val := reflect.ValueOf(b.PublicKeyCurve); !val.IsZero() {
		res["public_key_curve"] = b.PublicKeyCurve
	}

	if val := reflect.ValueOf(b.PublicKeyExponent); !val.IsZero() {
		res["public_key_exponent"] = b.PublicKeyExponent
	}

	if val := reflect.ValueOf(b.PublicKeySize); !val.IsZero() {
		res["public_key_size"] = b.PublicKeySize
	}

	if val := reflect.ValueOf(b.SerialNumber); !val.IsZero() {
		res["serial_number"] = b.SerialNumber
	}

	if val := reflect.ValueOf(b.SignatureAlgorithm); !val.IsZero() {
		res["signature_algorithm"] = b.SignatureAlgorithm
	}

	if val := reflect.ValueOf(b.Subject); !val.IsZero() {
		res["subject"] = b.Subject
	}

	if val := reflect.ValueOf(b.VersionNumber); !val.IsZero() {
		res["version_number"] = b.VersionNumber
	}

	return json.Marshal(res)
}

// TLSClientX509Issuer defines the object located at ECS path tls.client.x509.issuer.
type TLSClientX509Issuer struct {
	CommonName         []string `json:"common_name,omitempty" yaml:"common_name,omitempty" ecs:"tls.client.x509.issuer.common_name"`
	Country            []string `json:"country,omitempty" yaml:"country,omitempty" ecs:"tls.client.x509.issuer.country"`
	DistinguishedName  string   `json:"distinguished_name,omitempty" yaml:"distinguished_name,omitempty" ecs:"tls.client.x509.issuer.distinguished_name"`
	Locality           []string `json:"locality,omitempty" yaml:"locality,omitempty" ecs:"tls.client.x509.issuer.locality"`
	Organization       []string `json:"organization,omitempty" yaml:"organization,omitempty" ecs:"tls.client.x509.issuer.organization"`
	OrganizationalUnit []string `json:"organizational_unit,omitempty" yaml:"organizational_unit,omitempty" ecs:"tls.client.x509.issuer.organizational_unit"`
	StateOrProvince    []string `json:"state_or_province,omitempty" yaml:"state_or_province,omitempty" ecs:"tls.client.x509.issuer.state_or_province"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b TLSClientX509Issuer) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.CommonName); !val.IsZero() {
		res["common_name"] = b.CommonName
	}

	if val := reflect.ValueOf(b.Country); !val.IsZero() {
		res["country"] = b.Country
	}

	if val := reflect.ValueOf(b.DistinguishedName); !val.IsZero() {
		res["distinguished_name"] = b.DistinguishedName
	}

	if val := reflect.ValueOf(b.Locality); !val.IsZero() {
		res["locality"] = b.Locality
	}

	if val := reflect.ValueOf(b.Organization); !val.IsZero() {
		res["organization"] = b.Organization
	}

	if val := reflect.ValueOf(b.OrganizationalUnit); !val.IsZero() {
		res["organizational_unit"] = b.OrganizationalUnit
	}

	if val := reflect.ValueOf(b.StateOrProvince); !val.IsZero() {
		res["state_or_province"] = b.StateOrProvince
	}

	return json.Marshal(res)
}

// TLSClientX509Subject defines the object located at ECS path tls.client.x509.subject.
type TLSClientX509Subject struct {
	CommonName         []string `json:"common_name,omitempty" yaml:"common_name,omitempty" ecs:"tls.client.x509.subject.common_name"`
	Country            []string `json:"country,omitempty" yaml:"country,omitempty" ecs:"tls.client.x509.subject.country"`
	DistinguishedName  string   `json:"distinguished_name,omitempty" yaml:"distinguished_name,omitempty" ecs:"tls.client.x509.subject.distinguished_name"`
	Locality           []string `json:"locality,omitempty" yaml:"locality,omitempty" ecs:"tls.client.x509.subject.locality"`
	Organization       []string `json:"organization,omitempty" yaml:"organization,omitempty" ecs:"tls.client.x509.subject.organization"`
	OrganizationalUnit []string `json:"organizational_unit,omitempty" yaml:"organizational_unit,omitempty" ecs:"tls.client.x509.subject.organizational_unit"`
	StateOrProvince    []string `json:"state_or_province,omitempty" yaml:"state_or_province,omitempty" ecs:"tls.client.x509.subject.state_or_province"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b TLSClientX509Subject) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.CommonName); !val.IsZero() {
		res["common_name"] = b.CommonName
	}

	if val := reflect.ValueOf(b.Country); !val.IsZero() {
		res["country"] = b.Country
	}

	if val := reflect.ValueOf(b.DistinguishedName); !val.IsZero() {
		res["distinguished_name"] = b.DistinguishedName
	}

	if val := reflect.ValueOf(b.Locality); !val.IsZero() {
		res["locality"] = b.Locality
	}

	if val := reflect.ValueOf(b.Organization); !val.IsZero() {
		res["organization"] = b.Organization
	}

	if val := reflect.ValueOf(b.OrganizationalUnit); !val.IsZero() {
		res["organizational_unit"] = b.OrganizationalUnit
	}

	if val := reflect.ValueOf(b.StateOrProvince); !val.IsZero() {
		res["state_or_province"] = b.StateOrProvince
	}

	return json.Marshal(res)
}

// TLSServer defines the object located at ECS path tls.server.
type TLSServer struct {
	Certificate      string        `json:"certificate,omitempty" yaml:"certificate,omitempty" ecs:"tls.server.certificate"`
	CertificateChain []string      `json:"certificate_chain,omitempty" yaml:"certificate_chain,omitempty" ecs:"tls.server.certificate_chain"`
	Hash             TLSServerHash `json:"hash,omitempty" yaml:"hash,omitempty" ecs:"tls.server.hash"`
	Issuer           string        `json:"issuer,omitempty" yaml:"issuer,omitempty" ecs:"tls.server.issuer"`
	JA3S             string        `json:"ja3s,omitempty" yaml:"ja3s,omitempty" ecs:"tls.server.ja3s"`
	NotAfter         time.Time     `json:"not_after,omitempty" yaml:"not_after,omitempty" ecs:"tls.server.not_after"`
	NotBefore        time.Time     `json:"not_before,omitempty" yaml:"not_before,omitempty" ecs:"tls.server.not_before"`
	Subject          string        `json:"subject,omitempty" yaml:"subject,omitempty" ecs:"tls.server.subject"`
	X509             TLSServerX509 `json:"x509,omitempty" yaml:"x509,omitempty" ecs:"tls.server.x509"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b TLSServer) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Certificate); !val.IsZero() {
		res["certificate"] = b.Certificate
	}

	if val := reflect.ValueOf(b.CertificateChain); !val.IsZero() {
		res["certificate_chain"] = b.CertificateChain
	}

	if val := reflect.ValueOf(b.Hash); !val.IsZero() {
		res["hash"] = b.Hash
	}

	if val := reflect.ValueOf(b.Issuer); !val.IsZero() {
		res["issuer"] = b.Issuer
	}

	if val := reflect.ValueOf(b.JA3S); !val.IsZero() {
		res["ja3s"] = b.JA3S
	}

	if val := reflect.ValueOf(b.NotAfter); !val.IsZero() {
		res["not_after"] = b.NotAfter
	}

	if val := reflect.ValueOf(b.NotBefore); !val.IsZero() {
		res["not_before"] = b.NotBefore
	}

	if val := reflect.ValueOf(b.Subject); !val.IsZero() {
		res["subject"] = b.Subject
	}

	if val := reflect.ValueOf(b.X509); !val.IsZero() {
		res["x509"] = b.X509
	}

	return json.Marshal(res)
}

// TLSServerHash defines the object located at ECS path tls.server.hash.
type TLSServerHash struct {
	MD5    string `json:"md5,omitempty" yaml:"md5,omitempty" ecs:"tls.server.hash.md5"`
	SHA1   string `json:"sha1,omitempty" yaml:"sha1,omitempty" ecs:"tls.server.hash.sha1"`
	SHA256 string `json:"sha256,omitempty" yaml:"sha256,omitempty" ecs:"tls.server.hash.sha256"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b TLSServerHash) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.MD5); !val.IsZero() {
		res["md5"] = b.MD5
	}

	if val := reflect.ValueOf(b.SHA1); !val.IsZero() {
		res["sha1"] = b.SHA1
	}

	if val := reflect.ValueOf(b.SHA256); !val.IsZero() {
		res["sha256"] = b.SHA256
	}

	return json.Marshal(res)
}

// TLSServerX509 defines the object located at ECS path tls.server.x509.
type TLSServerX509 struct {
	AlternativeNames   []string             `json:"alternative_names,omitempty" yaml:"alternative_names,omitempty" ecs:"tls.server.x509.alternative_names"`
	Issuer             TLSServerX509Issuer  `json:"issuer,omitempty" yaml:"issuer,omitempty" ecs:"tls.server.x509.issuer"`
	NotAfter           time.Time            `json:"not_after,omitempty" yaml:"not_after,omitempty" ecs:"tls.server.x509.not_after"`
	NotBefore          time.Time            `json:"not_before,omitempty" yaml:"not_before,omitempty" ecs:"tls.server.x509.not_before"`
	PublicKeyAlgorithm string               `json:"public_key_algorithm,omitempty" yaml:"public_key_algorithm,omitempty" ecs:"tls.server.x509.public_key_algorithm"`
	PublicKeyCurve     string               `json:"public_key_curve,omitempty" yaml:"public_key_curve,omitempty" ecs:"tls.server.x509.public_key_curve"`
	PublicKeyExponent  json.Number          `json:"public_key_exponent,omitempty" yaml:"public_key_exponent,omitempty" ecs:"tls.server.x509.public_key_exponent"`
	PublicKeySize      json.Number          `json:"public_key_size,omitempty" yaml:"public_key_size,omitempty" ecs:"tls.server.x509.public_key_size"`
	SerialNumber       string               `json:"serial_number,omitempty" yaml:"serial_number,omitempty" ecs:"tls.server.x509.serial_number"`
	SignatureAlgorithm string               `json:"signature_algorithm,omitempty" yaml:"signature_algorithm,omitempty" ecs:"tls.server.x509.signature_algorithm"`
	Subject            TLSServerX509Subject `json:"subject,omitempty" yaml:"subject,omitempty" ecs:"tls.server.x509.subject"`
	VersionNumber      string               `json:"version_number,omitempty" yaml:"version_number,omitempty" ecs:"tls.server.x509.version_number"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b TLSServerX509) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.AlternativeNames); !val.IsZero() {
		res["alternative_names"] = b.AlternativeNames
	}

	if val := reflect.ValueOf(b.Issuer); !val.IsZero() {
		res["issuer"] = b.Issuer
	}

	if val := reflect.ValueOf(b.NotAfter); !val.IsZero() {
		res["not_after"] = b.NotAfter
	}

	if val := reflect.ValueOf(b.NotBefore); !val.IsZero() {
		res["not_before"] = b.NotBefore
	}

	if val := reflect.ValueOf(b.PublicKeyAlgorithm); !val.IsZero() {
		res["public_key_algorithm"] = b.PublicKeyAlgorithm
	}

	if val := reflect.ValueOf(b.PublicKeyCurve); !val.IsZero() {
		res["public_key_curve"] = b.PublicKeyCurve
	}

	if val := reflect.ValueOf(b.PublicKeyExponent); !val.IsZero() {
		res["public_key_exponent"] = b.PublicKeyExponent
	}

	if val := reflect.ValueOf(b.PublicKeySize); !val.IsZero() {
		res["public_key_size"] = b.PublicKeySize
	}

	if val := reflect.ValueOf(b.SerialNumber); !val.IsZero() {
		res["serial_number"] = b.SerialNumber
	}

	if val := reflect.ValueOf(b.SignatureAlgorithm); !val.IsZero() {
		res["signature_algorithm"] = b.SignatureAlgorithm
	}

	if val := reflect.ValueOf(b.Subject); !val.IsZero() {
		res["subject"] = b.Subject
	}

	if val := reflect.ValueOf(b.VersionNumber); !val.IsZero() {
		res["version_number"] = b.VersionNumber
	}

	return json.Marshal(res)
}

// TLSServerX509Issuer defines the object located at ECS path tls.server.x509.issuer.
type TLSServerX509Issuer struct {
	CommonName         []string `json:"common_name,omitempty" yaml:"common_name,omitempty" ecs:"tls.server.x509.issuer.common_name"`
	Country            []string `json:"country,omitempty" yaml:"country,omitempty" ecs:"tls.server.x509.issuer.country"`
	DistinguishedName  string   `json:"distinguished_name,omitempty" yaml:"distinguished_name,omitempty" ecs:"tls.server.x509.issuer.distinguished_name"`
	Locality           []string `json:"locality,omitempty" yaml:"locality,omitempty" ecs:"tls.server.x509.issuer.locality"`
	Organization       []string `json:"organization,omitempty" yaml:"organization,omitempty" ecs:"tls.server.x509.issuer.organization"`
	OrganizationalUnit []string `json:"organizational_unit,omitempty" yaml:"organizational_unit,omitempty" ecs:"tls.server.x509.issuer.organizational_unit"`
	StateOrProvince    []string `json:"state_or_province,omitempty" yaml:"state_or_province,omitempty" ecs:"tls.server.x509.issuer.state_or_province"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b TLSServerX509Issuer) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.CommonName); !val.IsZero() {
		res["common_name"] = b.CommonName
	}

	if val := reflect.ValueOf(b.Country); !val.IsZero() {
		res["country"] = b.Country
	}

	if val := reflect.ValueOf(b.DistinguishedName); !val.IsZero() {
		res["distinguished_name"] = b.DistinguishedName
	}

	if val := reflect.ValueOf(b.Locality); !val.IsZero() {
		res["locality"] = b.Locality
	}

	if val := reflect.ValueOf(b.Organization); !val.IsZero() {
		res["organization"] = b.Organization
	}

	if val := reflect.ValueOf(b.OrganizationalUnit); !val.IsZero() {
		res["organizational_unit"] = b.OrganizationalUnit
	}

	if val := reflect.ValueOf(b.StateOrProvince); !val.IsZero() {
		res["state_or_province"] = b.StateOrProvince
	}

	return json.Marshal(res)
}

// TLSServerX509Subject defines the object located at ECS path tls.server.x509.subject.
type TLSServerX509Subject struct {
	CommonName         []string `json:"common_name,omitempty" yaml:"common_name,omitempty" ecs:"tls.server.x509.subject.common_name"`
	Country            []string `json:"country,omitempty" yaml:"country,omitempty" ecs:"tls.server.x509.subject.country"`
	DistinguishedName  string   `json:"distinguished_name,omitempty" yaml:"distinguished_name,omitempty" ecs:"tls.server.x509.subject.distinguished_name"`
	Locality           []string `json:"locality,omitempty" yaml:"locality,omitempty" ecs:"tls.server.x509.subject.locality"`
	Organization       []string `json:"organization,omitempty" yaml:"organization,omitempty" ecs:"tls.server.x509.subject.organization"`
	OrganizationalUnit []string `json:"organizational_unit,omitempty" yaml:"organizational_unit,omitempty" ecs:"tls.server.x509.subject.organizational_unit"`
	StateOrProvince    []string `json:"state_or_province,omitempty" yaml:"state_or_province,omitempty" ecs:"tls.server.x509.subject.state_or_province"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b TLSServerX509Subject) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.CommonName); !val.IsZero() {
		res["common_name"] = b.CommonName
	}

	if val := reflect.ValueOf(b.Country); !val.IsZero() {
		res["country"] = b.Country
	}

	if val := reflect.ValueOf(b.DistinguishedName); !val.IsZero() {
		res["distinguished_name"] = b.DistinguishedName
	}

	if val := reflect.ValueOf(b.Locality); !val.IsZero() {
		res["locality"] = b.Locality
	}

	if val := reflect.ValueOf(b.Organization); !val.IsZero() {
		res["organization"] = b.Organization
	}

	if val := reflect.ValueOf(b.OrganizationalUnit); !val.IsZero() {
		res["organizational_unit"] = b.OrganizationalUnit
	}

	if val := reflect.ValueOf(b.StateOrProvince); !val.IsZero() {
		res["state_or_province"] = b.StateOrProvince
	}

	return json.Marshal(res)
}

// Trace defines the object located at ECS path trace.
type Trace struct {
	ID string `json:"id,omitempty" yaml:"id,omitempty" ecs:"trace.id"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b Trace) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	return json.Marshal(res)
}

// Transaction defines the object located at ECS path transaction.
type Transaction struct {
	ID string `json:"id,omitempty" yaml:"id,omitempty" ecs:"transaction.id"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b Transaction) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	return json.Marshal(res)
}

// URL defines the object located at ECS path url.
type URL struct {
	Domain           string      `json:"domain,omitempty" yaml:"domain,omitempty" ecs:"url.domain"`
	Extension        string      `json:"extension,omitempty" yaml:"extension,omitempty" ecs:"url.extension"`
	Fragment         string      `json:"fragment,omitempty" yaml:"fragment,omitempty" ecs:"url.fragment"`
	Full             string      `json:"full,omitempty" yaml:"full,omitempty" ecs:"url.full"`
	Original         string      `json:"original,omitempty" yaml:"original,omitempty" ecs:"url.original"`
	Password         string      `json:"password,omitempty" yaml:"password,omitempty" ecs:"url.password"`
	Path             string      `json:"path,omitempty" yaml:"path,omitempty" ecs:"url.path"`
	Port             json.Number `json:"port,omitempty" yaml:"port,omitempty" ecs:"url.port"`
	Query            string      `json:"query,omitempty" yaml:"query,omitempty" ecs:"url.query"`
	RegisteredDomain string      `json:"registered_domain,omitempty" yaml:"registered_domain,omitempty" ecs:"url.registered_domain"`
	Scheme           string      `json:"scheme,omitempty" yaml:"scheme,omitempty" ecs:"url.scheme"`
	TopLevelDomain   string      `json:"top_level_domain,omitempty" yaml:"top_level_domain,omitempty" ecs:"url.top_level_domain"`
	Username         string      `json:"username,omitempty" yaml:"username,omitempty" ecs:"url.username"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b URL) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Domain); !val.IsZero() {
		res["domain"] = b.Domain
	}

	if val := reflect.ValueOf(b.Extension); !val.IsZero() {
		res["extension"] = b.Extension
	}

	if val := reflect.ValueOf(b.Fragment); !val.IsZero() {
		res["fragment"] = b.Fragment
	}

	if val := reflect.ValueOf(b.Full); !val.IsZero() {
		res["full"] = b.Full
	}

	if val := reflect.ValueOf(b.Original); !val.IsZero() {
		res["original"] = b.Original
	}

	if val := reflect.ValueOf(b.Password); !val.IsZero() {
		res["password"] = b.Password
	}

	if val := reflect.ValueOf(b.Path); !val.IsZero() {
		res["path"] = b.Path
	}

	if val := reflect.ValueOf(b.Port); !val.IsZero() {
		res["port"] = b.Port
	}

	if val := reflect.ValueOf(b.Query); !val.IsZero() {
		res["query"] = b.Query
	}

	if val := reflect.ValueOf(b.RegisteredDomain); !val.IsZero() {
		res["registered_domain"] = b.RegisteredDomain
	}

	if val := reflect.ValueOf(b.Scheme); !val.IsZero() {
		res["scheme"] = b.Scheme
	}

	if val := reflect.ValueOf(b.TopLevelDomain); !val.IsZero() {
		res["top_level_domain"] = b.TopLevelDomain
	}

	if val := reflect.ValueOf(b.Username); !val.IsZero() {
		res["username"] = b.Username
	}

	return JSONMarshalNoHTMLEscape(res)
}

// User defines the object located at ECS path user.
type User struct {
	Domain   string    `json:"domain,omitempty" yaml:"domain,omitempty" ecs:"user.domain"`
	Email    string    `json:"email,omitempty" yaml:"email,omitempty" ecs:"user.email"`
	FullName string    `json:"full_name,omitempty" yaml:"full_name,omitempty" ecs:"user.full_name"`
	Group    UserGroup `json:"group,omitempty" yaml:"group,omitempty" ecs:"user.group"`
	Hash     string    `json:"hash,omitempty" yaml:"hash,omitempty" ecs:"user.hash"`
	ID       string    `json:"id,omitempty" yaml:"id,omitempty" ecs:"user.id"`
	Name     string    `json:"name,omitempty" yaml:"name,omitempty" ecs:"user.name"`
	Roles    []string  `json:"roles,omitempty" yaml:"roles,omitempty" ecs:"user.roles"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b User) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Domain); !val.IsZero() {
		res["domain"] = b.Domain
	}

	if val := reflect.ValueOf(b.Email); !val.IsZero() {
		res["email"] = b.Email
	}

	if val := reflect.ValueOf(b.FullName); !val.IsZero() {
		res["full_name"] = b.FullName
	}

	if val := reflect.ValueOf(b.Group); !val.IsZero() {
		res["group"] = b.Group
	}

	if val := reflect.ValueOf(b.Hash); !val.IsZero() {
		res["hash"] = b.Hash
	}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	if val := reflect.ValueOf(b.Roles); !val.IsZero() {
		res["roles"] = b.Roles
	}

	return json.Marshal(res)
}

// UserGroup defines the object located at ECS path user.group.
type UserGroup struct {
	Domain string `json:"domain,omitempty" yaml:"domain,omitempty" ecs:"user.group.domain"`
	ID     string `json:"id,omitempty" yaml:"id,omitempty" ecs:"user.group.id"`
	Name   string `json:"name,omitempty" yaml:"name,omitempty" ecs:"user.group.name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b UserGroup) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Domain); !val.IsZero() {
		res["domain"] = b.Domain
	}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	return json.Marshal(res)
}

// UserAgent defines the object located at ECS path user_agent.
type UserAgent struct {
	Device   UserAgentDevice `json:"device,omitempty" yaml:"device,omitempty" ecs:"user_agent.device"`
	Name     string          `json:"name,omitempty" yaml:"name,omitempty" ecs:"user_agent.name"`
	Original string          `json:"original,omitempty" yaml:"original,omitempty" ecs:"user_agent.original"`
	OS       UserAgentOS     `json:"os,omitempty" yaml:"os,omitempty" ecs:"user_agent.os"`
	Version  string          `json:"version,omitempty" yaml:"version,omitempty" ecs:"user_agent.version"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b UserAgent) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Device); !val.IsZero() {
		res["device"] = b.Device
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	if val := reflect.ValueOf(b.Original); !val.IsZero() {
		res["original"] = b.Original
	}

	if val := reflect.ValueOf(b.OS); !val.IsZero() {
		res["os"] = b.OS
	}

	if val := reflect.ValueOf(b.Version); !val.IsZero() {
		res["version"] = b.Version
	}

	return json.Marshal(res)
}

// UserAgentDevice defines the object located at ECS path user_agent.device.
type UserAgentDevice struct {
	Name string `json:"name,omitempty" yaml:"name,omitempty" ecs:"user_agent.device.name"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b UserAgentDevice) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	return json.Marshal(res)
}

// UserAgentOS defines the object located at ECS path user_agent.os.
type UserAgentOS struct {
	Family   string `json:"family,omitempty" yaml:"family,omitempty" ecs:"user_agent.os.family"`
	Full     string `json:"full,omitempty" yaml:"full,omitempty" ecs:"user_agent.os.full"`
	Kernel   string `json:"kernel,omitempty" yaml:"kernel,omitempty" ecs:"user_agent.os.kernel"`
	Name     string `json:"name,omitempty" yaml:"name,omitempty" ecs:"user_agent.os.name"`
	Platform string `json:"platform,omitempty" yaml:"platform,omitempty" ecs:"user_agent.os.platform"`
	Version  string `json:"version,omitempty" yaml:"version,omitempty" ecs:"user_agent.os.version"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b UserAgentOS) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Family); !val.IsZero() {
		res["family"] = b.Family
	}

	if val := reflect.ValueOf(b.Full); !val.IsZero() {
		res["full"] = b.Full
	}

	if val := reflect.ValueOf(b.Kernel); !val.IsZero() {
		res["kernel"] = b.Kernel
	}

	if val := reflect.ValueOf(b.Name); !val.IsZero() {
		res["name"] = b.Name
	}

	if val := reflect.ValueOf(b.Platform); !val.IsZero() {
		res["platform"] = b.Platform
	}

	if val := reflect.ValueOf(b.Version); !val.IsZero() {
		res["version"] = b.Version
	}

	return json.Marshal(res)
}

// Vulnerability defines the object located at ECS path vulnerability.
type Vulnerability struct {
	Category       []string             `json:"category,omitempty" yaml:"category,omitempty" ecs:"vulnerability.category"`
	Classification string               `json:"classification,omitempty" yaml:"classification,omitempty" ecs:"vulnerability.classification"`
	Description    string               `json:"description,omitempty" yaml:"description,omitempty" ecs:"vulnerability.description"`
	Enumeration    string               `json:"enumeration,omitempty" yaml:"enumeration,omitempty" ecs:"vulnerability.enumeration"`
	ID             string               `json:"id,omitempty" yaml:"id,omitempty" ecs:"vulnerability.id"`
	Reference      string               `json:"reference,omitempty" yaml:"reference,omitempty" ecs:"vulnerability.reference"`
	ReportID       string               `json:"report_id,omitempty" yaml:"report_id,omitempty" ecs:"vulnerability.report_id"`
	Scanner        VulnerabilityScanner `json:"scanner,omitempty" yaml:"scanner,omitempty" ecs:"vulnerability.scanner"`
	Score          VulnerabilityScore   `json:"score,omitempty" yaml:"score,omitempty" ecs:"vulnerability.score"`
	Severity       string               `json:"severity,omitempty" yaml:"severity,omitempty" ecs:"vulnerability.severity"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b Vulnerability) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Category); !val.IsZero() {
		res["category"] = b.Category
	}

	if val := reflect.ValueOf(b.Classification); !val.IsZero() {
		res["classification"] = b.Classification
	}

	if val := reflect.ValueOf(b.Description); !val.IsZero() {
		res["description"] = b.Description
	}

	if val := reflect.ValueOf(b.Enumeration); !val.IsZero() {
		res["enumeration"] = b.Enumeration
	}

	if val := reflect.ValueOf(b.ID); !val.IsZero() {
		res["id"] = b.ID
	}

	if val := reflect.ValueOf(b.Reference); !val.IsZero() {
		res["reference"] = b.Reference
	}

	if val := reflect.ValueOf(b.ReportID); !val.IsZero() {
		res["report_id"] = b.ReportID
	}

	if val := reflect.ValueOf(b.Scanner); !val.IsZero() {
		res["scanner"] = b.Scanner
	}

	if val := reflect.ValueOf(b.Score); !val.IsZero() {
		res["score"] = b.Score
	}

	if val := reflect.ValueOf(b.Severity); !val.IsZero() {
		res["severity"] = b.Severity
	}

	return json.Marshal(res)
}

// VulnerabilityScanner defines the object located at ECS path vulnerability.scanner.
type VulnerabilityScanner struct {
	Vendor string `json:"vendor,omitempty" yaml:"vendor,omitempty" ecs:"vulnerability.scanner.vendor"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b VulnerabilityScanner) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Vendor); !val.IsZero() {
		res["vendor"] = b.Vendor
	}

	return json.Marshal(res)
}

// VulnerabilityScore defines the object located at ECS path vulnerability.score.
type VulnerabilityScore struct {
	Base          json.Number `json:"base,omitempty" yaml:"base,omitempty" ecs:"vulnerability.score.base"`
	Environmental json.Number `json:"environmental,omitempty" yaml:"environmental,omitempty" ecs:"vulnerability.score.environmental"`
	Temporal      json.Number `json:"temporal,omitempty" yaml:"temporal,omitempty" ecs:"vulnerability.score.temporal"`
	Version       string      `json:"version,omitempty" yaml:"version,omitempty" ecs:"vulnerability.score.version"`
}

// MarshalJSON implements the json.Marshaler interface and removes zero values from returned JSON.
func (b VulnerabilityScore) MarshalJSON() ([]byte, error) {
	res := map[string]interface{}{}

	if val := reflect.ValueOf(b.Base); !val.IsZero() {
		res["base"] = b.Base
	}

	if val := reflect.ValueOf(b.Environmental); !val.IsZero() {
		res["environmental"] = b.Environmental
	}

	if val := reflect.ValueOf(b.Temporal); !val.IsZero() {
		res["temporal"] = b.Temporal
	}

	if val := reflect.ValueOf(b.Version); !val.IsZero() {
		res["version"] = b.Version
	}

	return json.Marshal(res)
}
